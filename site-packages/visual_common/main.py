from __future__ import print_function
# Variables starting with "_" are not accessible to the importing program

# TODO: Bug if "d = display(visible=True)"
#       view/window issues in centering objects in the canvas
# TOTO: material (getProcAddress), text/font issues
# TODO: window and canvas objects

## Need to handle the keyboard; display.keys is an "atomic queue" of strings
## Need to handle fullscreen, stereo

##https://groups.google.com/forum/?fromgroups=&hl=en#!topic/wxpython-users/lbzhzaBNkxQ
##On Linux one has to pass the depth buffer attribute like this:
##
##  attribs=[WX_GL_DEPTH_SIZE,16,0];  # Needed by wxGTK; the defaults are not enough
##  glcanvas.GLCanvas.__init__(self, parent, -1,attribList=attribs)
##
##I struggled for many days and tried most of the samples google could find.
##The fundamental problem seems to be that very few have been tested under X.

import wx as _wx
try:
    from wx import glcanvas
except ImportError:
    print("\n\nUnable to import glcanvas\n\n")
import imp as _imp
import sys as _sys
import os as _os
import time as _time

# http://wiki.wxwidgets.org/WxGLCanvas (wxWidgets)
# http://docs.wxwidgets.org/stable/wx_wxglcanvas.html (wxWidgets)
# http://wiki.wxpython.org/GLCanvas (2008; references the wxWidgets URLs above)
# http://www.siafoo.net/snippet/97 (updated 2009)
# http://code.activestate.com/recipes/325392-use-wxpythonopengl-to-draw-a-sphere/ (2004)

version = ('6.00', 'release')

import cvisual

from cvisual import (vector, dot, mag, mag2, norm, cross, rotate,
                       comp, proj, diff_angle, set_wait)
from primitives import (arrow, cylinder, cone, sphere, box, ring, label,
                               frame, pyramid, ellipsoid, curve, faces, convex, helix,
                               points, text, distant_light, local_light, extrusion)

import crayola
color = crayola
import materials
import controls
import graph
import shapes
import paths
import filedialog
import factorial

try:
    from Polygon import Polygon
except:
    pass

# The user program imports this module, which does the following:
#   (1) Use wxPython to set up the GUI, but not start MainLoop.
#   (2) Import the user (importing) program which imported this module.
#   (3) End with an infinite loop to keep the window
#       alive if the user program exits an animation loop.
# The user program must periodically call rate(), which drives the
# single-shot function _oneMainLoopIteration() to process events.

# All of this complexity is caused by the fact that the Cocoa framework
# on the Mac will not run if MainLoop is not in the primary thread.
# Basically, we've turned things inside out: Instead of directly executing
# the user's program, with the GUI in a secondary thread, the user's program
# imports this module which in turn imports the user's program.

# Any statements in the user program up to and including the import of
# this module get executed twice. The second import of this module is
# harmless, because no executable statements are performed the second time
# a module is imported.

# Additional complexity is caused by the fact that Python does not permit
# imports from a secondary thread (or inside a function in an import module).
# This made it impossible to put the user's program into a secondary thread
# unless all imports were processed "by hand" in this module, which is
# inelegant and problematic.

_lastrate = 0 # time of last call to rate()
_lastloop = 0
def rate(f): # limit a loop rate to f iterations per second
    global _lastrate, _lastloop
    dt = 1.0/f
    _lastrate += dt
    t = _time.time()
    domainloop = True
    if t > _lastloop+0.03:
        domainloop = False
        _Interact()
        _lastloop = t
    if _lastrate > t:
        if domainloop: _Interact()
        # sleep here isn't right, as it could be long; should instead do
        # short sleeps and call _oneMainLoopIteration() when appropriate.
        _time.sleep(_lastrate-t)
    else:
        if _lastrate < t-0.1: _lastrate = t

def sleep(dt):
    _Interact()
    _time.sleep(dt)

def wait(): # called by mouseobject.cpp/pop_click, which is called by scene.mouse.getclick()
    _Interact()
    _time.sleep(0.03)

class window(_wx.Frame):
    def __init__(self, disp, x, y, w, h, title):
        _wx.Frame.__init__(self, None, -1)
        self.disp = disp # for the moment, just one canvas per window
        self.win = _wx.Frame(None, -1, title, pos=[x, y], style=_wx.DEFAULT_FRAME_STYLE)
        _displays.window_num += 1
        self.N = _displays.window_num

        menuBar = _wx.MenuBar()
        menu = _wx.Menu()
        item = menu.Append(_wx.ID_EXIT, "E&xit\tCtrl-Q", "Exit demo")
        self.win.Bind(_wx.EVT_MENU, self._OnExitApp, item)
        menuBar.Append(menu, "&File")
        
        self.win.SetMenuBar(menuBar)
        self.win.Bind(_wx.EVT_CLOSE, self._OnExitApp)
        self.win.Bind(_wx.EVT_MOVE, self._OnMove)
        self.win.Bind(_wx.EVT_SIZE, self._OnSize)

        self.win.SetSize((w, h))
        self.win.Show(True)
##        self.win.SetTopWindow(self.win)

##        print(_wx.SystemSettings.GetMetric(_wx.SYS_BORDER_X)) # 1 on Windows
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_BORDER_Y)) # 1
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X)) # 8
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y)) # 8
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_SCREEN_X)) # 1920
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_SCREEN_Y)) # 1200
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y)) # 20
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y)) # 22
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_EDGE_X)) # 2
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_EDGE_Y)) # 2
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_WINDOWMIN_X)) # 132
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_WINDOWMIN_Y)) # 38
##        print('--------------')

        # Title bar height is FRAMESIZE_Y + CAPTION_Y = 30 on Windows
        # Menu bar height is MENU_Y = 20 on Windows
        # Thickness of bottom is FRAMESIZE_Y = 8 on Windows
        #   So height of canvas is scene.height - 58
        #   and width of canvas is scene.width - 16

        # The display size is (self._width-dw, self._height-dh)
##        dw = 2*(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X) -
##                _wx.SystemSettings.GetMetric(_wx.SYS_EDGE_X))
##        dh = 2*(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y) +
##                _wx.SystemSettings.GetMetric(_wx.SYS_BORDER_Y) +
##                _wx.SystemSettings.GetMetric(_wx.SYS_EDGE_Y)) + \
##                _wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y) + \
##                _wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y)
        
    def _OnExitApp(self, evt):
        _wx.Exit()

    def _OnMove(self, evt):
        self.disp._x, self.disp._y = evt.GetPosition()
        self.disp._width = self.disp.width
        self.disp._height = self.disp.height
        self.disp._report_resize()
        _Interact()
        evt.Skip()
        
    def _OnSize(self, evt):
        self.disp._width, self.disp._height = evt.GetSize()
        self.disp._x = self.disp.x
        self.disp._y = self.disp.y
        self.disp._report_resize()
        _Interact()
        evt.Skip()

##class mouseclick(cvisual.display_kernel.mouse):
##    def __init__(self):
##        cvisual.display_kernel.mouse.__init__(self)
##
##    def getclick(self):
##        while True:
##            _Interact()
##            if scene.mouse.events > 0:
##                m = scene.mouse.getevent()
##                if m.click: return
##            _time.sleep(0.03)

class display(cvisual.display_kernel, glcanvas.GLCanvas):
    # wrap_display_kernel.cpp makes available to Python, in addition to
    # render_scene, report_mouse_state, and report_mouse_state,
    # the methods report_window_resize, report_view_resize, and pick.
        
    def getclick(self): # works in the form scene.getclick()
        while True:
            if self.mouse.events > 0:
                m = self.mouse.getevent()
                if m.click: return m
            sleep(0.03)
            
    def __init__(self, **keywords):
        cvisual.display_kernel.__init__(self)
        self._window_initialized = False
        self.N = -1
        
        self.material = materials.diffuse
        # If visible is set before width (say), can get error "can't change window".
        # So deal with visible attribute separately.
        vis = None
        if 'visible' in keywords:
            visible = keywords['visible']
            del keywords['visible']
        keys = list(keywords.keys())
        keys.sort()
        for kw in keys:
            setattr(self, kw, keywords[kw])
        if vis is not None: setattr(self, 'visible', vis)
        if 'ambient' not in keywords:
            self.ambient = (0.2,0.2,0.2)
        self._leftdown = self._rightdown = 0
        self._cursorx = 0
        self._cursory = 0
        self._spinning = False
        
        cvisual.display_kernel.set_selected(self)
        
        if 'lights' not in keywords:
            distant_light( direction=(0.22, 0.44, 0.88), color=(0.8,0.8,0.8) )
            distant_light( direction=(-0.88, -0.22, -.44), color=(0.3,0.3,0.3) )
            
    def _make_canvas(self):
        # http://xoomer.virgilio.it/infinity77/wxPython/glcanvas/wx.glcanvas.GLCanvas.html
        # http://xoomer.virgilio.it/infinity77/wxPython/glcanvas/wx.glcanvas.GLContext.html        
        glcanvas.GLCanvas.__init__(self, self.window.win, -1, pos=[0,0], size=[self.width, self.height])
        self._context = glcanvas.GLContext(self)
        
        self.Bind(_wx.EVT_LEFT_DOWN, self._OnLeftMouseDown)
        self.Bind(_wx.EVT_LEFT_UP, self._OnLeftMouseUp)
        self.Bind(_wx.EVT_MIDDLE_DOWN, self._OnMiddleMouseDown)
        self.Bind(_wx.EVT_MIDDLE_UP, self._OnMiddleMouseUp)
        self.Bind(_wx.EVT_RIGHT_DOWN, self._OnRightMouseDown)
        self.Bind(_wx.EVT_RIGHT_UP, self._OnRightMouseUp)
        self.Bind(_wx.EVT_MOTION, self._OnMouseMotion)
        #self.Bind(_wx.EVT_MOUSEWHEEL, self.OnMouseWheel)
        
        # The size of the canvas can also be determined by comparing
        # GetSize() and GetClientSize():
        size = self.window.win.GetSize()
        canvas_size = self.window.win.GetClientSize()
        dw = size[0] - canvas_size[0] # canvas is dw thinner than scene.width
        dh = size[1] - canvas_size[1] # canvas is dh shorter than scene.height

    def _report_resize(self):
        self.report_window_resize(int(self._x), int(self._y), int(self._width), int(self._height))
        self.report_view_resize(int(self._width), int(self._height))
        
    def _activate( self, a ):
        self._activated = a
        if a:
            _displays.add(self)            
            if not self._window_initialized:
                self._create()
                self._window_initialized = True         

    def _create(self):
        _displays.display_num += 1
        self.N = _displays.display_num
        self.window = window(self, self.x, self.y, self.width, self.height, self.title)
        self._make_canvas()
        self._x = self.x
        self._y = self.y
        self._width = self.width
        self._height = self.height
        self._report_resize()
        _Interact()

    def _destroy(self):
        _displays.remove(self)
        self.window.win.Destroy()
        self.window.win = None
        self.report_closed()

# From wxPython/OpenGL demo:
##    def DoSetViewport(self): # called when canvas resized
##        size = self.size = self.GetClientSize()
##        self.SetCurrent(self.context)
##        glViewport(0, 0, size.width, size.height)

##    def update(self): # not sure what this is for
##        if not self._activated:
##            self._destroy()
##            return
##        if not self.win: self._create()
        
    def _paint(self):
        if not self._window_initialized: return
        self.SetCurrent(self._context)
        self.render_scene()
        self.SwapBuffers()
        # glFinish()?

## mouse event codes: http://docs.wxwidgets.org/2.8.4/wx_wxmouseevent.html#wxmouseevent
    def _OnLeftMouseDown(self, evt):
        if self._rightdown:
            if self.userzoom: self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_BLANK))
            else: self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_ARROW))
        self.CaptureMouse() # can drag outside of our window
        self._leftdown = 1
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnLeftMouseUp(self, evt):
        self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_ARROW))
        self._leftdown = 0
        self._report_mouse_state(evt)
        self.ReleaseMouse() # undo CaptureMouse

    def _OnMiddleMouseDown(self, evt):
        if self.userzoom: self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_BLANK))
        self.CaptureMouse() # can drag outside of our window
        self._leftdown = self._rightdown = 1
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnMiddleMouseUp(self, evt):
        self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_ARROW))
        self._leftdown = self._rightdown = 0
        self._report_mouse_state(evt)
        self.ReleaseMouse()

    def _OnRightMouseDown(self, evt):
        if (self._leftdown and self.userzoom) or (not self._leftdown and self.userspin):
            self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_BLANK))
            self._cursorx, self._cursory = evt.GetPosition()
            self._spinning = True
        self.CaptureMouse()
        self._rightdown = 1
        x, y = evt.GetPosition()
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnRightMouseUp(self, evt):
        self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_ARROW))
        if self._spinning: # reset mouse to original location
            self.window.win.WarpPointer(self._cursorx, self._cursory)            
        self._spinning = False
        self._rightdown = 0
        self._report_mouse_state(evt)
        self.ReleaseMouse()

##    def OnMouseWheel(self, evt): # not supported by VPython 5.x
##        print(evt.GetWheelRotation(), evt.GetWheelDelta())

    def _OnMouseMotion(self, evt):
        self._report_mouse_state(evt)
            
# Mouse state, including ctrl/alt etc. http://wxpython.org/docs/api/wx.MouseState-class.html
    def _report_mouse_state(self, evt): # wx gives x,y relative to upper left corner
        x, y = evt.GetPosition()
        self.report_mouse_state([self._leftdown, self._rightdown],
                    x, y,
                    [evt.ShiftDown(), evt.ControlDown(), evt.AltDown(), evt.CmdDown()],
                    0)
        
##    def getclick(self): # need to track scene.mouse.clicked
##        print('my own getclick')
##        while True:
##            _Interact()
##            if scene.mouse.events > 0:
##                m = scene.mouse.getevent()
##                if m.click:
##                    print('it is a click; return')
##                    return
##                print('not a click')
##            _time.sleep(0.03)

###########################################################################################

    def _getProcAddress(self, name):
        import ctypes
        return 0
##        if hasattr( pyglet.gl, "lib_glx" ) and pyglet.gl.lib_glx.pyglet.gl.lib_glx._have_getprocaddress:
##            ptr = pyglet.gl.lib_glx.pyglet.gl.lib_glx.glXGetProcAddressARB(name)
##        elif hasattr( pyglet.gl, "lib_wgl" ):
##            ptr = pyglet.gl.lib_wgl.wglGetProcAddress(name)
##        elif hasattr( pyglet.gl, "lib_agl" ):
##            try:
##                ptr = getattr(pyglet.gl.lib_agl.gl_lib, name)
##            except AttributeError,e:
##                return 0
##        else:
##            return 0
##        ptr = ctypes.cast( ptr, ctypes.c_void_p ).value or 0
##        return ptr

    def _return_objects(self):
        return tuple([ o for o in self._get_objects() if not isinstance(o, cvisual.light) ])
    objects = property( _return_objects, None, None)

    def _get_lights(self):
        # TODO: List comprehension used for Python 2.3 compatibility; replace with
        #   generator comprehension
        return tuple([ o for o in self._get_objects() if isinstance(o, cvisual.light) ])
    
    def _set_lights(self, n_lights):
        old_lights = self._get_lights()
        for lt in old_lights:
            lt.visible = False

        if (type(n_lights) is not list) and (type(n_lights) is not tuple):
            n_lights = [n_lights] # handles case of scene.lights = single light
        for lt in n_lights:
            if isinstance( lt, cvisual.light ):  #< TODO: should this be allowed?
                lt.display = self
                lt.visible = True
            else:
                lum = cvisual.vector(lt).mag
                distant_light( direction=cvisual.vector(lt).norm(),
                               color=(lum,lum,lum),
                               display=self )
        
    ambient = property( cvisual.display_kernel._get_ambient, cvisual.display_kernel._set_ambient)
    range = property( cvisual.display_kernel._get_range, cvisual.display_kernel._set_range)
    lights = property( _get_lights, _set_lights, None)

class _ManageDisplays(): # a singleton
    def __init__(self):
        set_wait(wait)
        self.displays = []
        self.window_num = 0     
        self.display_num = 0

    def add(self, d):
        self.displays.append(d)

    def remove(self, d):
        self.displays.remove(d)

    def paint_displays(self):
        for d in self.displays:
            d._paint()

_App = _wx.App()
_displays = _ManageDisplays()
scene = display()
_evtloop = _wx.GUIEventLoop()
_wx.EventLoop.SetActive(_evtloop)
_isMac = ('wxOSX' in _wx.PlatformInfo)

# The essence of _Interact was provided by Robin Dunn, developer of wxPython
def _Interact():
    _displays.paint_displays()
    
    while not _evtloop.Pending() and _evtloop.ProcessIdle(): pass
    if _wx.GetApp(): _wx.GetApp().ProcessPendingEvents()
    if _isMac and not _evtloop.Dispatch(): return
    # Currently on wxOSX Pending always returns true, so the
    # ProcessIdle above is not ever called. Call it here instead.
    if _isMac: _evtloop.ProcessIdle()
    
    while True:
        checkAgain = False
        if _wx.GetApp() and _wx.GetApp().HasPendingEvents():
            _wx.GetApp().ProcessPendingEvents()
            checkAgain = True
        if not _isMac and _evtloop.Pending():
            _evtloop.Dispatch()
            checkAgain = True
        if not checkAgain:
            break

_imp.load_source('', _sys.argv[0]) # import the user's program

while len(_displays.displays) > 0: # at end of user program, wait for user to close the program
    rate(30)
_os._exit(0)
