import time
import sys
from numpy import random

# * Check to see whether something like 1/30 second has elapsed since
# the last time it called the interact function and if so, call it. This
# ensures that the scene stays alive to zoom and rotate.
# 
# * Clamp the number of loop iterations performed per second.
# 
# The tricky issue here is that, as you can see, there are two different
# timing issues, something I hadn't appreciated when I wrote the current
# version of the rate function. This wasn't an issue with the existing
# version of VPython, where rate didn't have to worry about scheduling
# scene rendering, because that was driven by interrupts.
# 
# There is one other aspect of rate with the existing VPython. It keeps
# a running average of the average time required to render the scene and
# tries to make sure that the users's computations and rendering each
# consume about half of the time, because if either the user
# computations or the rendering is starved for time, the program becomes
# unresponsive. Of course, if there isn't a lot of computation, one
# still wants to render about 30 times per second so that zoom and
# rotate are responsive.
# 

INTERACT_PERIOD=0.03
BALANCE_RATIO=0.5

if sys.platform[:3] == 'win':
    # On Windows, the best timer is supposedly time.clock()
    clock = time.clock
else:
    # On most other platforms, the best timer is supposedly time.time()
    clock = time.time

class TimingDebug:

    def __init__(self, debug=0): # set to one to collect debugging times
        self.tlist = []
        self.start = clock()
        self.debug = debug
        
    def add(self, msg):
        if self.debug: 
            self.tlist.append("t: %10.6f, %s" % (clock()-self.start,msg))
        
    def dump(self):
        if self.debug:
            print '\n'.join(self.tlist)
        else:
            print "debugging disabled"

td = TimingDebug(debug=0)
        
class simulateDelay:
    """
    Simulate rendering/compute times.. with an average value of delayAvg with 
    a variance of something like delaySigma**2.
    """

    def __init__(self, delayAvg=0.001, delaySigma=0.0001):
        self.delayAvg=delayAvg
        self.delaySigma=delaySigma
        self.callTimes = []
        
    def __call__(self):
        self.callTimes.append(clock())
        time.sleep(random.normal()*self.delaySigma + self.delayAvg)
        td.add("delay called")

class RateKeeper:
    # TODO: Adjust interactPeriod if user code is starved
    def __init__(self, interactPeriod=INTERACT_PERIOD, interactFunc=simulateDelay):
        self.interactionPeriod = interactPeriod
        self.interactFunc = interactFunc
        self.userTime = 0.0
        self.count = 0
        self.renderTime = 0.0
        self.lastCalledTime = None
        self.tstart = clock()
        td.add("RK created")
        
    def callInteract(self):
        self.lastInteractCalled = dt = clock() 
        self.interactFunc()
        dt = clock() - dt
        self.renderTime = 0.95*self.renderTime + 0.05*dt # running average or render time
        
    def __call__(self, maxRate=100):
        #td.add('-------------------------')
        calledTime = clock()
        if self.lastCalledTime is None: # first time rate has been called
            self.lastCalledTime = self.lastInteractCalled = self.lastEndRate = calledTime
        
        dt = calledTime - self.lastEndRate # time spent in user code
        if self.count == 1: self.userTime = dt # the first time we have a user code time
        else: self.userTime = 0.95*self.userTime + 0.05*dt
        self.count += 1
        delta = 1.0/maxRate  # target for time 
        
        desiredFinishTime = calledTime + delta - self.userTime # when we should return
        self.lastCalledTime = calledTime

        if desiredFinishTime <= calledTime: # overdue; no waiting, but may need to call Interact
            if calledTime > self.lastInteractCalled + self.interactionPeriod:
                self.callInteract()
        elif desiredFinishTime > self.lastInteractCalled + self.interactionPeriod: # need to call Interact
            while desiredFinishTime > self.lastInteractCalled + self.interactionPeriod:
                delay = self.lastInteractCalled + self.interactionPeriod - calledTime
                if delay > 0 : time.sleep(delay)
                self.callInteract() # callInteract updates self.lastInteractCalled
                calledTime = clock()
            if desiredFinishTime > calledTime:
                time.sleep(desiredFinishTime - calledTime)
        else: # The requested rate is high; don't call Interact this time
            time.sleep(desiredFinishTime - calledTime)
            
        self.lastEndRate = clock()
        if self.lastEndRate < desiredFinishTime:
            time.sleep(desiredFinishTime - self.lastEndRate)
            self.lastEndRate = clock()

##        td.add('%1f %1f %1f' % (self.lastEndRate - self.lastCalledTime, self.renderTime, self.userTime))
##        if self.lastEndRate - self.tstart > 7:
##            td.dump()
##            self.tstart = self.lastEndRate + 5000

if __name__=='__main__':
    #
    # test timing functions
    #
    from numpy import array, sqrt

    print "testing rate plan..."    

    print "testing slow rate... should take around 20 seconds"

    ifunc = simulateDelay(delayAvg=0.001)
    rate = RateKeeper(interactFunc=ifunc)
    procTimes = []

    for i in range(40):
        procTimes.append(clock())
        rate(2)
        time.sleep(0.0001)
        
    callTimes = array(ifunc.callTimes)
    procTimes = array(procTimes)
    cdiffs = callTimes[1:] - callTimes[:-1]
    pdiffs = procTimes[1:] - procTimes[:-1]
    cavg = cdiffs.sum()/len(cdiffs)
    cstd = sqrt((cdiffs**2).sum()/len(cdiffs) - cavg**2)
    pavg = pdiffs.sum()/len(pdiffs)
    pstd = sqrt((pdiffs**2).sum()/len(pdiffs) - pavg**2)
    print "loop time statistics: loop time agv:", pavg, "stdev:", pstd
    print "interact time stats:  interact period avg:", cavg, "stdev:", cstd
    

    print "testing high rate... should take around 0.5 seconds"
    
    ifunc = simulateDelay(delayAvg=0.001)
    rate = RateKeeper(interactFunc=ifunc)
    procTimes = []    

    for i in range(100):
        procTimes.append(clock())
        rate(200)
        time.sleep(0.0001)
        
    callTimes = array(ifunc.callTimes)
    procTimes = array(procTimes)
    cdiffs = callTimes[1:] - callTimes[:-1]
    pdiffs = procTimes[1:] - procTimes[:-1]
    cavg = cdiffs.sum()/len(cdiffs)
    cstd = sqrt((cdiffs**2).sum()/len(cdiffs) - cavg**2)
    pavg = pdiffs.sum()/len(pdiffs)
    pstd = sqrt((pdiffs**2).sum()/len(pdiffs) - pavg**2)
    print "loop time statistics: loop time agv:", pavg, "stdev:", pstd
    print "interact time stats:  interact period avg:", cavg, "stdev:", cstd
