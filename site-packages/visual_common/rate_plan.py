from time import sleep, time
from numpy import random

# * Check to see whether something like 1/30 second has elapsed since
# the last time it called the interact function and if so, call it. This
# ensures that the scene stays alive to zoom and rotate.
# 
# * Clamp the number of loop iterations performed per second.
# 
# The tricky issue here is that, as you can see, there are two different
# timing issues, something I hadn't appreciated when I wrote the current
# version of the rate function. This wasn't an issue with the existing
# version of VPython, where rate didn't have to worry about scheduling
# scene rendering, because that was driven by interrupts.
# 
# There is one other aspect of rate with the existing VPython. It keeps
# a running average of the average time required to render the scene and
# tries to make sure that the users's computations and rendering each
# consume about half of the time, because if either the user
# computations or the rendering is starved for time, the program becomes
# unresponsive. Of course, if there isn't a lot of computation, one
# still wants to render about 30 times per second so that zoom and
# rotate are responsive.
# 

HISTORY_SIZE=10
INTERACT_PERIOD=0.03
BALANCE_RATIO=0.5

class TimingDebug:

    def __init__(self):
        self.tlist = []
        self.start = time()
        
    def add(self, msg):
        if 0: # set to one to collect debugging times
            self.tlist.append("t: %10.6f, %s" % (time()-self.start,msg))
        
    def dump(self):
        print '\n'.join(self.tlist)

td = TimingDebug()
        
class simulateDelay:
    """
    Simulate rendering/compute times.. with an average value of delayAvg with 
    a variance of something like delaySigma**2.
    """

    def __init__(self, delayAvg=0.001, delaySigma=0.0001):
        self.delayAvg=delayAvg
        self.delaySigma=delaySigma
        self.callTimes = []
        
    def __call__(self):
        self.callTimes.append(time())
        sleep(random.normal()*self.delaySigma + self.delayAvg)
        td.add("delay called")

class RateKeeper:
    """
    Proposed solution for rate command. 
    """
    def __init__(self, interactPeriod=INTERACT_PERIOD, interactFunc=simulateDelay, historySize=HISTORY_SIZE):
        self.interactionPeriod = interactPeriod
        self.lastCalledTime = 0.0
        self.lastInteractCalled = 0.0
        self.historyTimes=[]  # history of interact periods
        self.interactFunc = interactFunc
        self.historySize = historySize
        td.add("RK created")
        
    def callInteract(self):
        self.lastInteractCalled = beforeInteract = time()
        td.add("interact called setting: %lf" % beforeInteract)        
        self.interactFunc()
        afterInteract = time()
        self.historyTimes.append(afterInteract - beforeInteract)   # try to measure the interact time
        self.historyTimes = self.historyTimes[-self.historySize:]  # keep the last historySize entries
        
    def averageInteract(self):
        return sum(self.historyTimes)/len(self.historyTimes)
        
    def __call__(self, maxRate=100):
        td.add('-------------------------')
        calledTime = time()
        td.add('setting called time: %lf' % calledTime)
        if self.lastCalledTime <= 0.0:
            td.add('initing lastCalledTime...')
            self.lastInteractCalled = self.lastCalledTime = calledTime # we've never been called... do our best.
        
        delta = 1.0/maxRate  # target for time 
        desiredFinishTime = self.lastCalledTime + delta
        td.add('rate called (delta %lf), (dft %lf)' % (delta, desiredFinishTime))
        self.lastCalledTime = calledTime

        if delta > self.interactionPeriod:
            #
            # the requested rate is lower than the minimum interact period, call interact multiple times
            #
            td.add('delta > ip')
            if not self.historyTimes:
                self.callInteract()  # no history yet... call once just to get some idea
                
            now = time()
            avgInteract = self.averageInteract()
            td.add('ai, ip:' + `avgInteract` + ':' + `self.interactionPeriod`)
            if avgInteract < self.interactionPeriod:
                #
                # the average render time is less than the interactPeriod, we'll need to sleep.
                #
                numLoops = (desiredFinishTime - now)/self.interactionPeriod
                loopCount = 0
                beginLoops = now
                while now < desiredFinishTime:
                    self.callInteract()
                    loopCount += 1
                    desiredLoopTime = beginLoops + loopCount*self.interactionPeriod
                    currTime = time()
                    if desiredLoopTime > currTime:
                        sleep(desiredLoopTime - currTime)
                    now = time()
            else:
                #
                # the average render time period is longer than the interactPeriod. Ouch!
                # Just call interact once... and hope it's not too long...
                #
                self.callInteract()
        else:
            #
            # the requested rate is higher than the minimum interact period...
            #
            td.add('delta < ip')
            desiredInteractTime = self.lastInteractCalled + self.interactionPeriod
            td.add('dft - dit:' + `desiredFinishTime - desiredInteractTime`)
            if desiredFinishTime > desiredInteractTime:
                #
                # we need to call interact this time.
                #
                self.callInteract()

            currTime = time()
            if desiredFinishTime > currTime:
                sleep(desiredFinishTime - currTime)

if __name__=='__main__':
    #
    # test timing functions
    #
    from pylab import array, hist, show
    
    ifunc = simulateDelay(delayAvg=0.001)
    rate = RateKeeper(interactFunc=ifunc)
    for i in range(100):
        rate(20)
        sleep(0.01)
        
    callTimes = array(ifunc.callTimes)
    diffs = callTimes[1:] - callTimes[:-1]
    hist(diffs)
    show()
    
    