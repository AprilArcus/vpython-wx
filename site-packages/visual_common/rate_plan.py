from time import sleep, time
from numpy import random

# * Check to see whether something like 1/30 second has elapsed since
# the last time it called the interact function and if so, call it. This
# ensures that the scene stays alive to zoom and rotate.
# 
# * Clamp the number of loop iterations performed per second.
# 
# The tricky issue here is that, as you can see, there are two different
# timing issues, something I hadn't appreciated when I wrote the current
# version of the rate function. This wasn't an issue with the existing
# version of VPython, where rate didn't have to worry about scheduling
# scene rendering, because that was driven by interrupts.
# 
# There is one other aspect of rate with the existing VPython. It keeps
# a running average of the average time required to render the scene and
# tries to make sure that the users's computations and rendering each
# consume about half of the time, because if either the user
# computations or the rendering is starved for time, the program becomes
# unresponsive. Of course, if there isn't a lot of computation, one
# still wants to render about 30 times per second so that zoom and
# rotate are responsive.
# 

HISTORY_SIZE=10
INTERACT_PERIOD=0.03
BALANCE_RATIO=0.5

class TimingDebug:

    def __init__(self, debug=0): # set to one to collect debugging times
        self.tlist = []
        self.start = time()
        self.debug = debug
        
    def add(self, msg):
        if self.debug: 
            self.tlist.append("t: %10.6f, %s" % (time()-self.start,msg))
        
    def dump(self):
        if self.debug:
            print '\n'.join(self.tlist)
        else:
            print "debugging disabled"

td = TimingDebug(debug=0)
        
class simulateDelay:
    """
    Simulate rendering/compute times.. with an average value of delayAvg with 
    a variance of something like delaySigma**2.
    """

    def __init__(self, delayAvg=0.001, delaySigma=0.0001):
        self.delayAvg=delayAvg
        self.delaySigma=delaySigma
        self.callTimes = []
        
    def __call__(self):
        self.callTimes.append(time())
        sleep(random.normal()*self.delaySigma + self.delayAvg)
        td.add("delay called")

class RateKeeper:
    """
    Proposed solution for rate command. 
    """
    def __init__(self, interactPeriod=INTERACT_PERIOD, interactFunc=simulateDelay, historySize=HISTORY_SIZE):
        self.interactionPeriod = interactPeriod
        self.callCount = 0
        self.lastCalledTime = 0.0
        self.lastInteractCalled = 0.0
        self.firstCalledTime = None
        self.historyTimes=[]  # history of interact periods
        self.interactFunc = interactFunc
        self.historySize = historySize
        td.add("RK created")
        
    def callInteract(self):
        self.lastInteractCalled = beforeInteract = time()
        td.add("interact called setting: %lf" % beforeInteract) 
        self.interactFunc()
        afterInteract = time()
        self.historyTimes.append(afterInteract - beforeInteract)   # try to measure the interact time
        self.historyTimes = self.historyTimes[-self.historySize:]  # keep the last historySize entries
        
    def averageInteract(self):
        return sum(self.historyTimes)/len(self.historyTimes)
        
    def __call__(self, maxRate=100):
        td.add('-------------------------')
        self.callCount += 1
        calledTime = time()
        delta = 1.0/maxRate  # target for time 
        td.add('setting called time: %lf' % calledTime)
        
        if self.firstCalledTime is None:
            td.add('initing lastCalledTime...')
            self.lastInteractCalled = calledTime # we've never been called... do our best.
            self.firstCalledTime = calledTime

        self.lastCalledTime = calledTime
        
        desiredFinishTime = self.firstCalledTime + delta*(self.callCount-1) # when should we finish this time?

        td.add('rate called (delta %lf), (dft %lf)' % (delta, desiredFinishTime))

        if delta > self.interactionPeriod:
            #
            # the requested rate is lower than the minimum interact period, call interact multiple times
            #
            td.add('delta > ip')
            if not self.historyTimes:
                self.callInteract()  # no history yet... call once just to get some idea
                
            avgInteract = self.averageInteract()
            td.add('ai, ip:' + `avgInteract` + ':' + `self.interactionPeriod`)
            if avgInteract < self.interactionPeriod:
                #
                # the average render time is less than the interactPeriod, we'll need to sleep.
                #
                now = time()
                numLoops = (desiredFinishTime - now)/self.interactionPeriod
                loopCount = 0
                beginLoops = now
                while now < desiredFinishTime:
                    self.callInteract()
                    loopCount += 1
                    desiredLoopTime = beginLoops + loopCount*self.interactionPeriod
                    currTime = time()
                    if desiredLoopTime > currTime:
                        sleep(desiredLoopTime - currTime)
                    now = time()
            else:
                #
                # the average render time period is longer than the interactPeriod. Ouch!
                # Just call interact ... and hope it's not too long...
                #
                now = time()
                while now < desiredFinishTime:
                    self.callInteract()
                    now = time()
        else:
            #
            # the requested rate is higher than the minimum interact period...
            #
            td.add('delta < ip')
            desiredInteractTime = self.lastInteractCalled + self.interactionPeriod
            td.add('dft - dit:' + `desiredFinishTime - desiredInteractTime`)
            if desiredFinishTime > desiredInteractTime:
                #
                # we need to call interact this time.
                #
                self.callInteract()

            currTime = time()
            if desiredFinishTime > currTime:
                sleep(desiredFinishTime - currTime)

if __name__=='__main__':
    #
    # test timing functions
    #
    from numpy import array, sqrt

    print "testing rate plan..."    

    print "testing slow rate... should take around 20 seconds"

    ifunc = simulateDelay(delayAvg=0.001)
    rate = RateKeeper(interactFunc=ifunc)
    procTimes = []

    for i in range(40):
        procTimes.append(time())
        rate(2)
        sleep(0.0001)
        
    callTimes = array(ifunc.callTimes)
    procTimes = array(procTimes)
    cdiffs = callTimes[1:] - callTimes[:-1]
    pdiffs = procTimes[1:] - procTimes[:-1]
    cavg = cdiffs.sum()/len(cdiffs)
    cstd = sqrt((cdiffs**2).sum()/len(cdiffs) - cavg**2)
    pavg = pdiffs.sum()/len(pdiffs)
    pstd = sqrt((pdiffs**2).sum()/len(pdiffs) - pavg**2)
    print "loop time statistics: loop time agv:", pavg, "stdev:", pstd
    print "interact time stats:  interact period avg:", cavg, "stdev:", cstd
    

    print "testing high rate... should take around 0.5 seconds"
    
    ifunc = simulateDelay(delayAvg=0.001)
    rate = RateKeeper(interactFunc=ifunc)
    procTimes = []    

    for i in range(100):
        procTimes.append(time())
        rate(200)
        sleep(0.0001)
        
    callTimes = array(ifunc.callTimes)
    procTimes = array(procTimes)
    cdiffs = callTimes[1:] - callTimes[:-1]
    pdiffs = procTimes[1:] - procTimes[:-1]
    cavg = cdiffs.sum()/len(cdiffs)
    cstd = sqrt((cdiffs**2).sum()/len(cdiffs) - cavg**2)
    pavg = pdiffs.sum()/len(pdiffs)
    pstd = sqrt((pdiffs**2).sum()/len(pdiffs) - pavg**2)
    print "loop time statistics: loop time agv:", pavg, "stdev:", pstd
    print "interact time stats:  interact period avg:", cavg, "stdev:", cstd
