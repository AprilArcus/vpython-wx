from __future__ import print_function

# Don't import filedialog here?
# gyro2.py trail unaffected by setting interval or retain

# Variables starting with "_" are not accessible to the importing program

# When running from a terminal get this warning:
# swig/python detected a memory leak of type wxPlatformInfo *', no destructor found.
# Probably doesn't matter.

##https://groups.google.com/forum/?fromgroups=&hl=en#!topic/wxpython-users/lbzhzaBNkxQ
##On Linux one has to pass the depth buffer attribute like this:
##
##  attribs=[WX_GL_DEPTH_SIZE,16,0];  # Needed by wxGTK; the defaults are not enough
##  glcanvas.GLCanvas.__init__(self, parent, -1,attribList=attribs)
##
##I struggled for many days and tried most of the samples google could find.
##The fundamental problem seems to be that very few have been tested under X.

import wx as _wx
try:
    from wx import glcanvas
except ImportError:
    print("\n\nUnable to import glcanvas\n\n")
import os as _os
import time as _time
import numpy as _numpy

# http://wiki.wxwidgets.org/WxGLCanvas (wxWidgets)
# http://docs.wxwidgets.org/stable/wx_wxglcanvas.html (wxWidgets)
# http://wiki.wxpython.org/GLCanvas (2008; references the wxWidgets URLs above)
# http://www.siafoo.net/snippet/97 (updated 2009)
# http://code.activestate.com/recipes/325392-use-wxpythonopengl-to-draw-a-sphere/ (2004)

version = ('6.00', 'release')

import visual_common.cvisual as cvisual

from visual_common.cvisual import (vector, dot, mag, mag2, norm, cross, rotate,
                       comp, proj, diff_angle, set_wait)
from visual_common.primitives import (arrow, cylinder, cone, sphere, box, ring, label,
                               frame, pyramid, ellipsoid, curve, faces, convex, helix,
                               points, text, distant_light, local_light, extrusion,
                               text_to_bitmap)

import visual_common.crayola as crayola
color = crayola
import visual_common.materials as materials
import visual_common.shapes as shapes
import visual_common.paths as paths
#import visual_common.filedialog as filedialog
import visual_common.factorial as factorial

try:
    from Polygon import Polygon
except:
    pass

# The user program imports this module, which does the following:
#   (1) Use wxPython to set up the GUI, but not start MainLoop.
#   (2) Import the user (importing) program which imported this module.
#   (3) End with an infinite loop to keep the window
#       alive if the user program exits an animation loop.
# The user program must periodically call rate(), which drives the
# single-shot function _oneMainLoopIteration() to process events.

# All of this complexity is caused by the fact that the Cocoa framework
# on the Mac will not run if MainLoop is not in the primary thread.
# Basically, we've turned things inside out: Instead of directly executing
# the user's program, with the GUI in a secondary thread, the user's program
# imports this module which in turn imports the user's program.

# Any statements in the user program up to and including the import of
# this module get executed twice. The second import of this module is
# harmless, because no executable statements are performed the second time
# a module is imported.

# Additional complexity is caused by the fact that Python does not permit
# imports from a secondary thread (or inside a function in an import module).
# This made it impossible to put the user's program into a secondary thread
# unless all imports were processed "by hand" in this module, which is
# inelegant and problematic.



_lastrate = 0 # time of last call to rate()
_lastloop = 0
def old_rate(f): # limit a loop rate to f iterations per second
    global _lastrate, _lastloop
    dt = 1.0/f
    _lastrate += dt
    t = _time.time()
    domainloop = True
    if t > _lastloop+0.03:
        domainloop = False
        _Interact()
        _lastloop = t
    if _lastrate > t:
        if domainloop: _Interact()
        # sleep here isn't right, as it could be long; should instead do
        # short sleeps and call _oneMainLoopIteration() when appropriate.
        _time.sleep(_lastrate-t)
    else:
        if _lastrate < t-0.1: _lastrate = t

def sleep(dt):
    _Interact()
    _time.sleep(dt)

def wait(*args): # called by mouseobject.cpp/pop_click, which is called by scene.mouse.getclick()
    _Interact()
    if len(args) == 0: return
    elif len(args) == 1: _time.sleep(args[0])
    else: raise ValueError("Too many arguments for the wait() function.")

_App = _wx.App()

_plat = _wx.PlatformInformation()
_plat = _plat.GetOperatingSystemFamilyName() # 'Windows', 'Macintosh'

class window(_wx.Frame):
    def __init__(self, disp, x, y, w, h, title):
        _wx.Frame.__init__(self, None, -1)
        self.disp = disp # for the moment, just one canvas per window
        if _plat == 'Macintosh': y += 20
        self.win = _wx.Frame(None, -1, title, pos=[x, y], style=_wx.DEFAULT_FRAME_STYLE)
        _displays.window_num += 1
        self.N = _displays.window_num

        menuBar = _wx.MenuBar()
        menu = _wx.Menu()
        item = menu.Append(_wx.ID_EXIT, "E&xit\tCtrl-Q", "Exit demo")
        self.win.Bind(_wx.EVT_MENU, self._OnExitApp, item)
        menuBar.Append(menu, "&File")
        
        self.win.SetMenuBar(menuBar)
        self.win.Bind(_wx.EVT_CLOSE, self._OnExitApp)
        self.win.Bind(_wx.EVT_MOVE, self._OnMove)
        self.win.Bind(_wx.EVT_SIZE, self._OnSize)

        self.win.SetSize((w, h))
        self.win.Show(True)
        
    def _OnExitApp(self, evt):
        _wx.Exit()

    def _OnMove(self, evt):
        self.disp._x, self.disp._y = evt.GetPosition()
        self.disp._width = self.disp.width
        self.disp._height = self.disp.height
        self.disp._report_resize()
        _Interact()
        evt.Skip()
        
    def _OnSize(self, evt):
        self.disp._width, self.disp._height = evt.GetSize()
        self.disp._x = self.disp.x
        self.disp._y = self.disp.y
        self.disp._report_resize()
        _Interact()
        evt.Skip()


class _mouseTracker:
    """
    mouseTracker is a simple class that's whole purpose in life is to
    keep track of the physical and logical state of the mouse so the
    display handler can focus on display. It's also easily separately
    testable this way.
    """

    def __init__(self):
        """
        leftDown, rightDown, middleDown are *physical* states
        spinning and zooming are *logical* states that depend
        on history and optional key-states. lastSpinning and
        lastZooming are used to check for the lock state when
        zooming and spinning are initiated.

        'captured' just keeps track of the current captured state of the mouse
        'cursx', and 'cursy' are memory for the mouse position when them mouse
        is hidden and restored.
        """
        self.leftIsDown = self.rightIsDown = self.middleIsDown = 0
        self.lastSpinning = self.lastZooming = 0
        
    def leftDown(self):
        self.leftIsDown = 1
        
    def leftUp(self):
        self.leftIsDown = 0
        
    def rightDown(self):
        self.rightIsDown = 1
        
    def rightUp(self):
        self.rightIsDown = 0

    def midDown(self):
        self.middleIsDown = 1
        
    def midUp(self):
        self.middleIsDown = 0
        
    def isZooming(self, evt, userzoom=True, userspin=True):
        """
        Check to see if we're zooming. On a three button mouse
        this is done with the middle button. On a two button mouse
        this is done with both left/right buttons pressed simultaneously
        On a one button mouse this is done with the 'alt' key pressed along
        with the left button.
        """
        zooming = 0

        if not userzoom:
            return zooming
            
        if self.middleIsDown:
            zooming = 1
            
        elif self.leftIsDown and self.rightIsDown:
            zooming = 1
            
        elif self.leftIsDown and evt.AltDown():
            zooming = 1
        
        elif self.leftIsDown and evt.ControlDown():
            zooming = 1
            
        return zooming
        
    def isSpinning(self, evt, userzoom=True, userspin=True, zooming=False):
        """
        Check to see if we're spinning. One a two button mouse
        this is done with the right button UNLESS the left
        button is also down. So.. check for zooming first and 
        return False if we are. Then check for spinning and
        return accordingly.
        """
        
        spinning = 0
        if not userspin or zooming or self.isZooming(evt, userzoom, userspin):
            return spinning
            
        elif self.rightIsDown:
            spinning = 1
            
        return spinning
        
    def checkLock(self, spinning, zooming):
        """
        Check to see if spinning and/or zooming has just
        been initiated. If so, return True, otherwise return False.
        """
        result = 0
        if spinning:
            if not self.lastSpinning:
                result = 1
                self.lastSpinning = 1
        else:
            self.lastSpinning = 0
            
        if zooming:
            if not self.lastZooming:
                result = 1
                self.lastZooming = 1
        else:
            self.lastZooming = 0
            
        return result
                
class display(cvisual.display_kernel, glcanvas.GLCanvas):
    # wrap_display_kernel.cpp makes available to Python, in addition to
    # render_scene, report_mouse_state, and report_mouse_state,
    # the methods report_window_resize, report_view_resize, and pick.
            
    def __init__(self, **keywords):
        cvisual.display_kernel.__init__(self)
        self._window_initialized = False
        self.N = -1
        
        self.material = materials.diffuse
        # If visible is set before width (say), can get error "can't change window".
        # So deal with visible attribute separately.
        v = None
        if 'visible' in keywords:
            visible = keywords['visible']
            del keywords['visible']
        keys = list(keywords.keys())
        keys.sort()
        for kw in keys:
            setattr(self, kw, keywords[kw])
        if v is not None: setattr(self, 'visible', v)
        if 'ambient' not in keywords:
            self.ambient = (0.2,0.2,0.2)
            
        self._mt = _mouseTracker()
        self._captured = 0
        self._cursorx = self._cursory = 0
        
        self.select()
        
        if 'lights' not in keywords:
            distant_light( direction=(0.22, 0.44, 0.88), color=(0.8,0.8,0.8) )
            distant_light( direction=(-0.88, -0.22, -.44), color=(0.3,0.3,0.3) )

    def select(self):
        cvisual.display_kernel.set_selected(self)

    def get_dw(self):
        return _dw

    def get_dh(self):
        return _dh

    dw = property(get_dw, None, None)
    dh = property(get_dh, None, None)
            
    def _make_canvas(self):
        # http://xoomer.virgilio.it/infinity77/wxPython/glcanvas/wx.glcanvas.GLCanvas.html
        # http://xoomer.virgilio.it/infinity77/wxPython/glcanvas/wx.glcanvas.GLContext.html
        
        glcanvas.GLCanvas.__init__(self, self.window.win, -1, pos=[0,0],
                                   size=[self._width-_dw, self._height-_dh])
        self._context = glcanvas.GLContext(self) # = wxGLCanvas&
        
        self.Bind(_wx.EVT_LEFT_DOWN, self._OnLeftMouseDown)
        self.Bind(_wx.EVT_LEFT_UP, self._OnLeftMouseUp)
        self.Bind(_wx.EVT_MIDDLE_DOWN, self._OnMiddleMouseDown)
        self.Bind(_wx.EVT_MIDDLE_UP, self._OnMiddleMouseUp)
        self.Bind(_wx.EVT_RIGHT_DOWN, self._OnRightMouseDown)
        self.Bind(_wx.EVT_RIGHT_UP, self._OnRightMouseUp)
        self.Bind(_wx.EVT_MOTION, self._OnMouseMotion)
        self.Bind(_wx.EVT_LEFT_DCLICK, self._OnLeftDClick)
        self.Bind(_wx.EVT_RIGHT_DCLICK, self._OnRightDClick)
        self.Bind(_wx.EVT_MIDDLE_DCLICK, self._OnMiddleDClick)
        
        #self.Bind(_wx.EVT_MOUSEWHEEL, self.OnMouseWheel)

        self.Bind(_wx.EVT_CHAR, self._OnCharEvent)

    def _report_resize(self):
        self.report_window_resize(int(self._x), int(self._y), int(self._width), int(self._height))
        self.report_view_resize(int(self._width-_dw), int(self._height-_dh))
        
    def _activate( self, a ):
        self._activated = a
        if a:
            _displays.add(self)            
            if not self._window_initialized:
                self._create()
                self._window_initialized = True         

    def _create(self):
        _displays.display_num += 1
        self.N = _displays.display_num
        self.window = window(self, self.x, self.y, self.width, self.height, self.title)
        self._make_canvas()
        self._x = self.x
        self._y = self.y
        self._width = self.width
        self._height = self.height
        self._report_resize()
        _Interact()

    def _destroy(self):
        _displays.remove(self)
        self.window.win.Destroy()
        self.window.win = None
        self.report_closed()

##    def update(self): # not sure what this is for
##        if not self._activated:
##            self._destroy()
##            return
##        if not self.win: self._create()
        
    def _paint(self):
        if not self._window_initialized: return
        self.SetCurrent(self._context)
        self.render_scene()
        self.SwapBuffers()
        # glFinish()?

## mouse event codes: http://docs.wxwidgets.org/2.8.4/wx_wxmouseevent.html#wxmouseevent

    def _OnLeftDClick(self, evt):
        self._OnLeftMouseDown(evt)
        self._OnLeftMouseUp(evt)
        self._OnLeftMouseDown(evt)
        
    def _OnRightDClick(self, evt):
        self._OnRightMouseDown(evt)
        self._OnRightMouseUp(evt)
        self._OnRightMouseDown(evt)

    def _OnMiddleDClick(self, evt):
        self._OnMiddleMouseDown(evt)
        self._OnMiddleMouseUp(evt)
        self._OnMiddleMouseDown(evt)
        
    def _OnLeftMouseDown(self, evt):
        self._mt.leftDown()
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnLeftMouseUp(self, evt):
        self._mt.leftUp()
        self._report_mouse_state(evt)

    def _OnRightMouseDown(self, evt):
        self._mt.rightDown()
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnRightMouseUp(self, evt):
        self._mt.rightUp()
        self._report_mouse_state(evt)

    def _OnMiddleMouseDown(self, evt):
        self._mt.midDown()
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnMiddleMouseUp(self, evt):
        self._mt.midUp()
        self._report_mouse_state(evt)

##    def OnMouseWheel(self, evt): # not supported by VPython 5.x
##        print(evt.GetWheelRotation(), evt.GetWheelDelta())

    def _OnMouseMotion(self, evt):
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus
        
            
# Mouse state, including ctrl/alt etc. http://wxpython.org/docs/api/wx.MouseState-class.html
# On Mac:
# CTRL + 1-button mouse = no CTRL, right button, presumably because CTRL-mouse == "right button"
# ALT  + 1-button mouse = ALT, left button
# CMD  + 1-button mouse = CTRL and CMD, left button

    def _report_mouse_state(self, evt): # wx gives x,y relative to upper left corner
        x, y = evt.GetPosition()

        zooming = self._mt.isZooming(evt, self.userzoom, self.userspin)
        spinning = self._mt.isSpinning(evt, self.userzoom, self.userspin, zooming)

        lock = self._mt.checkLock(spinning, zooming)
        
        if lock and not self._captured:
            self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_BLANK))
            self._cursorx, self._cursory = evt.GetPosition()
            self.CaptureMouse()
            self._captured = True
        elif self._captured and not (spinning or zooming):
            self.window.win.WarpPointer(self._cursorx, self._cursory)
            self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_ARROW))
            self.ReleaseMouse()          
            self._captured = False
        
        left = self._mt.leftIsDown
        right = spinning or self._mt.rightIsDown
        middle = zooming or self._mt.middleIsDown
        shift = evt.ShiftDown()
        ctrl = evt.ControlDown()
        alt = evt.AltDown()
        cmd = evt.CmdDown()
                
        #if _plat == 'Macintosh' and ctrl and cmd:
        #    ctrl = False
##        print('-------------------------')
##        print(x, y, left, middle, right, '   ', shift, ctrl, alt, cmd)
##        if trigger == 'leftdown' and not self._rightdown:
##            if ctrl:
##                right = 1
##                left = 0
##            elif alt:
##                middle = 1
##                left = 0

            
##        print(lock, x, y, left, middle, right, '   ', shift, ctrl, alt, cmd)
        self.report_mouse_state([left, right, middle],
                x, y,
                [shift, ctrl, alt, cmd],
                lock)
##        if (self._spinning or self._zooming): # reset mouse to original location
##                self.window.win.WarpPointer(self._cursorx, self._cursory)

    # caps lock not the same as shift key down
    def _OnCharEvent(self, evt):
        key = evt.GetKeyCode()
        shift = evt.ShiftDown()
        if key > 127:
            if   key == 310: k = 'break'
            elif key == 312: k = 'end'
            elif key == 313: k = 'home'
            elif key == 314: k = 'left'
            elif key == 315: k = 'up'
            elif key == 316: k = 'right'
            elif key == 317: k = 'down'
            elif key == 322: k = 'insert'
            elif key == 340: k = 'f1'
            elif key == 341: k = 'f2'
            elif key == 342: k = 'f3'
            elif key == 343: k = 'f4'
            elif key == 344: k = 'f5'
            elif key == 345: k = 'f6'
            elif key == 346: k = 'f7'
            elif key == 347: k = 'f8'
            elif key == 348: k = 'f9'
            elif key == 349: k = 'f10'
            elif key == 366: k = 'page up'
            elif key == 367: k = 'page down'
            else: k = 'invalid key'
        else:
            if shift: k = _shifted[key]
            else: k = _unshifted[key]
        self.pushkey(k)
        evt.Skip()

    def _return_objects(self):
        return tuple([ o for o in self._get_objects() if not isinstance(o, cvisual.light) ])
    objects = property( _return_objects, None, None)

    def _get_lights(self):
        # TODO: List comprehension used for Python 2.3 compatibility; replace with
        #   generator comprehension
        return tuple([ o for o in self._get_objects() if isinstance(o, cvisual.light) ])
    
    def _set_lights(self, n_lights):
        old_lights = self._get_lights()
        for lt in old_lights:
            lt.visible = False

        if (type(n_lights) is not list) and (type(n_lights) is not tuple):
            n_lights = [n_lights] # handles case of scene.lights = single light
        for lt in n_lights:
            if isinstance( lt, cvisual.light ):  #< TODO: should this be allowed?
                lt.display = self
                lt.visible = True
            else:
                lum = cvisual.vector(lt).mag
                distant_light( direction=cvisual.vector(lt).norm(),
                               color=(lum,lum,lum),
                               display=self )
        
    ambient = property( cvisual.display_kernel._get_ambient, cvisual.display_kernel._set_ambient)
    range = property( cvisual.display_kernel._get_range, cvisual.display_kernel._set_range)
    lights = property( _get_lights, _set_lights, None)

class _ManageDisplays(): # a singleton
    def __init__(self):
        set_wait(wait)
        self.displays = []
        self.window_num = 0     
        self.display_num = 0

    def add(self, d):
        self.displays.append(d)

    def remove(self, d):
        self.displays.remove(d)

    def paint_displays(self):
        for d in self.displays:
            d._paint()

# The essence of _Interact was provided by Robin Dunn, developer of wxPython
def _Interact():
    _displays.paint_displays()
    
    while not _evtloop.Pending() and _evtloop.ProcessIdle(): pass
    if _wx.GetApp(): _wx.GetApp().ProcessPendingEvents()
    if _isMac and not _evtloop.Dispatch(): return
    # Currently on wxOSX Pending always returns true, so the
    # ProcessIdle above is not ever called. Call it here instead.
    if _isMac: _evtloop.ProcessIdle()
    
    while True:
        checkAgain = False
        if _wx.GetApp() and _wx.GetApp().HasPendingEvents():
            _wx.GetApp().ProcessPendingEvents()
            checkAgain = True
        if not _isMac and _evtloop.Pending():
            _evtloop.Dispatch()
            checkAgain = True
        if not checkAgain:
            break

from rate_plan import RateKeeper as _rk
rate = _rk(interactFunc=_Interact)

_displays = _ManageDisplays()
displays = _displays.displays
_evtloop = _wx.GUIEventLoop()
_wx.EventLoop.SetActive(_evtloop)
_isMac = ('wxOSX' in _wx.PlatformInfo)

##        print(_wx.SystemSettings.GetMetric(_wx.SYS_BORDER_X)) # 1 on Windows
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_BORDER_Y)) # 1
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X)) # 8
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y)) # 8
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_SCREEN_X)) # 1920
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_SCREEN_Y)) # 1200
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y)) # 20
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y)) # 22
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_EDGE_X)) # 2
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_EDGE_Y)) # 2
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_WINDOWMIN_X)) # 132
##        print(_wx.SystemSettings.GetMetric(_wx.SYS_WINDOWMIN_Y)) # 38
##        print('--------------')

# Title bar height is FRAMESIZE_Y + CAPTION_Y = 30 on Windows
# Menu bar height is MENU_Y = 20 on Windows
# Thickness of bottom is FRAMESIZE_Y = 8 on Windows
#   So height of canvas is scene.height - 58
#   and width of canvas is scene.width - 16

# The canvas size is (self._width-_dw, self._height-_dh)
_dw = 2*(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X))
_dh = 2*(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y)) + \
        _wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y) + \
        _wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y)
        
##        # The canvas size can also be determined by comparing GetSize() and GetClientSize(),
##        # after the window and canvas have been created:
##        size = self.window.win.GetSize()
##        canvas_size = self.window.win.GetClientSize()
##        self._dw = size[0] - canvas_size[0] # canvas is dw thinner than scene.width
##        self._dh = size[1] - canvas_size[1] # canvas is dh shorter than scene.height

# Tables for converting US keyboard inputs to characters
_unshifted = ['', '', '', '', '', '', '', '', 'backspace', 'tab', # 0-9
   '', '', '', 'enter', '', '', 'shift', 'ctrl', 'alt', '', # 10-19
   'caps lock', '', '', '', '', '', '', 'esc', '', '', #20-29
   '', '', ' ', '', '', '', '', '', '', "'", # 30-39
   '', '', '', '', ',', '-', '.', '/', '0', '1', # 40-49
   '2', '3', '4', '5', '6', '7', '8', '9', '', ';', # 50-59
   '', '=', '', '', '', '', '', '', '', '', # 60-69
   '', '', '', '', '', '', '', '', '', '', # 70-79
   '', '', '', '', '', '', '', '', '', '', # 80-89
   '', '[', '\\', ']', '', '', '`', 'a', 'b', 'c', # 90-99
   'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', # 100-109
   'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', # 110-119
   'x', 'y', 'z', '', '', '', '', 'delete'] #120-127
   
_shifted = ['', '', '', '', '', '', '', '', 'backspace', 'tab', # 0-9
   '', '', '', 'enter', '', '', 'shift', 'ctrl', 'alt', 'break', # 10-19
   'caps lock', '', '', '', '', '', '', 'esc', '', '', #20-29
   '', '', '', '!', '"', '#', '$', '%', '&', '', # 30-39
   '(', ')', '*', '+', '', 'insert', 'delete', '', '', '!', # 40-49
   '@', '#', '$', '%', '^', '&', '*', '(', ':', '', # 50-59
   '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', # 60-69
   'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', # 70-79
   'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', # 80-89
   'Z', '', '', '', '^', '_', '0', '1', '2', '3', # 90-99
   '4', '5', '6', '7', '8', '9', '*', '+', '', '', # 100-109
   '', '', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', # 110-119
   'f9', 'f10', '', '{', '|', '}', '~', 'delete'] #120-127

