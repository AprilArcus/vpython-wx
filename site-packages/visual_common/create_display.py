from __future__ import print_function

# BUG: gyro2.py trail unaffected by setting interval or retain

# Variables starting with "_" are not accessible to the importing program

# When running from a terminal get this warning:
# swig/python detected a memory leak of type wxPlatformInfo *', no destructor found.
# Probably doesn't matter.

##https://groups.google.com/forum/?fromgroups=&hl=en#!topic/wxpython-users/lbzhzaBNkxQ
##On Linux one has to pass the depth buffer attribute like this:
##
##  attribs=[WX_GL_DEPTH_SIZE,16,0];  # Needed by wxGTK; the defaults are not enough
##  glcanvas.GLCanvas.__init__(self, parent, -1,attribList=attribs)
##
##I struggled for many days and tried most of the samples google could find.
##The fundamental problem seems to be that very few have been tested under X.

import wx as _wx
try:
    from wx import glcanvas
except ImportError:
    print("\n\nUnable to import glcanvas\n\n")
import os as _os
import time as _time
import numpy as _numpy
from string import lower as _lower

# http://wiki.wxwidgets.org/WxGLCanvas (wxWidgets)
# http://docs.wxwidgets.org/stable/wx_wxglcanvas.html (wxWidgets)
# http://wiki.wxpython.org/GLCanvas (2008; references the wxWidgets URLs above)
# http://www.siafoo.net/snippet/97 (updated 2009)
# http://code.activestate.com/recipes/325392-use-wxpythonopengl-to-draw-a-sphere/ (2004)

version = ('6.02', 'release')

import visual_common.cvisual as cvisual

from visual_common.cvisual import (vector, dot, mag, mag2, norm, cross, rotate,
                       comp, proj, diff_angle, set_wait)
from visual_common.primitives import (arrow, cylinder, cone, sphere, box, ring, label,
                               frame, pyramid, ellipsoid, curve, faces, convex, helix,
                               points, text, distant_light, local_light, extrusion,
                               text_to_bitmap)

import visual_common.crayola as crayola
color = crayola
import visual_common.materials as materials
import visual_common.shapes as shapes
import visual_common.paths as paths

EVENT_NAMES = (
    "click", "mousedown", "mousemove", "mouseup", "keydown", "keyup",
    "redraw", "draw_complete", "char")
              

try:
    from Polygon import Polygon
except:
    pass

def wait(*args): # called by mouseobject.cpp/pop_click, which is called by scene.mouse.getclick()
    _Interact()
    if len(args) == 0: return
    elif len(args) == 1: _time.sleep(args[0])
    else: raise ValueError("Too many arguments for the wait() function.")

_App = _wx.App()

_plat = _wx.PlatformInformation()
_plat = _plat.GetOperatingSystemFamilyName() # 'Windows', 'Macintosh'

class window(_wx.Frame):
    def __init__(self, _make_panel=True, x=0, y=0, width=600, height=600, title='VPython'):
        _wx.Frame.__init__(self, None, -1)
        if _plat == 'Macintosh': y += 20
        self.win = _wx.Frame(None, -1, title, pos=(x, y), style=_wx.DEFAULT_FRAME_STYLE)
        _displays.window_num += 1
        self.N = _displays.window_num
        self._canvas = None # not None if one canvas fills the window
        if _make_panel: # Must not create a panel if user program does not call window
            self.panel = _wx.Panel(self.win)
        self.menubar = _wx.MenuBar()
        
        menu = _wx.Menu()
        item = menu.Append(_wx.ID_EXIT, "E&xit\tCtrl-Q", "Exit demo")
        self.win.Bind(_wx.EVT_MENU, self._OnExitApp, item)
        self.menubar.Append(menu, "&File")
        
        self.win.SetMenuBar(self.menubar)
        self.win.Bind(_wx.EVT_CLOSE, self._OnExitApp)
        self.win.Bind(_wx.EVT_MOVE, self._OnMove)
        self.win.Bind(_wx.EVT_SIZE, self._OnSize)

        self.win.SetSize((width, height))
        self.win.Show(True)

    def _add_display(self, disp):
        self._canvas = disp
        
    def _OnExitApp(self, evt):
        _wx.Exit()

    def _OnMove(self, evt):
        c = self._canvas
        if c is not None:
            c._x, c._y = evt.GetPosition()
            if _plat == 'Windows':
                c._x -= _wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X)
                c._y -= _wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y) + \
                                _wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y) + \
                                _wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y)
            c._width = c.width
            c._height = c.height
            c._report_resize()
        _Interact()
        evt.Skip()
        
    def _OnSize(self, evt):
        c = self._canvas
        if c is not None:
            c._width, c._height = evt.GetSize()
            c._x = c.x
            c._y = c.y
            c._report_resize()
        _Interact()
        evt.Skip()

    @classmethod
    def get_dw(cls):
        return _dw

    @classmethod
    def get_dh(cls):
        return _dh

class _mouseTracker:
    """
    mouseTracker is a simple class that's whole purpose in life is to
    keep track of the physical and logical state of the mouse so the
    display handler can focus on display. It's also easily separately
    testable this way.
    """

    def __init__(self):
        """
        leftDown, rightDown, middleDown are *physical* states
        spinning and zooming are *logical* states that depend
        on history and optional key-states. lastSpinning and
        lastZooming are used to check for the lock state when
        zooming and spinning are initiated.
        """
        self.leftIsDown = self.rightIsDown = self.middleIsDown = 0
        self.lastSpinning = self.lastZooming = 0
        
    def leftDown(self):
        self.leftIsDown = 1
        
    def leftUp(self):
        self.leftIsDown = 0
        
    def rightDown(self):
        self.rightIsDown = 1
        
    def rightUp(self):
        self.rightIsDown = 0

    def midDown(self):
        self.middleIsDown = 1
        
    def midUp(self):
        self.middleIsDown = 0
        
    def isZooming(self, evt, userzoom=True, userspin=True):
        """
        Check to see if we're zooming. On a three button mouse
        this is done with the middle button. On a two button mouse
        this is done with both left/right buttons pressed simultaneously
        On a one button mouse this is done with the 'alt' key pressed along
        with the left button.
        """
        zooming = 0

        if not userzoom:
            return zooming
            
        if self.middleIsDown:
            zooming = 1
            
        elif self.leftIsDown and self.rightIsDown:
            zooming = 1
            
        elif self.leftIsDown and evt.AltDown():
            zooming = 1
        
        elif self.leftIsDown and evt.ControlDown():
            zooming = 1
            
        return zooming
        
    def isSpinning(self, evt, userzoom=True, userspin=True, zooming=False):
        """
        Check to see if we're spinning. One a two button mouse
        this is done with the right button UNLESS the left
        button is also down. So.. check for zooming first and 
        return False if we are. Then check for spinning and
        return accordingly.
        """
        
        spinning = 0
        if not userspin or zooming or self.isZooming(evt, userzoom, userspin):
            return spinning
            
        elif self.rightIsDown:
            spinning = 1
            
        return spinning
        
    def checkLock(self, spinning, zooming):
        """
        Check to see if spinning and/or zooming has just
        been initiated. If so, return True, otherwise return False.
        """
        result = 0
        if spinning:
            if not self.lastSpinning:
                result = 1
                self.lastSpinning = 1
        else:
            self.lastSpinning = 0
            
        if zooming:
            if not self.lastZooming:
                result = 1
                self.lastZooming = 1
        else:
            self.lastZooming = 0
            
        return result
        
class binding_enabler(object):
    """
    just here to enable or disable bindings
    """
    def __init__(self, display, namestring, fn=None, enabled=True):
        self.display = display
        self.name = namestring
        self.fn = fn
        self.enabled = enabled
        
    def start(self):
        """
        try to support multiple events
        """
        if not self.enabled:
            self.enabled = True
            for name in self.name.split():
                self.display._enable_binding(name, self.fn, self.enabled)
        
    def stop(self):
        """
        try to support multiple events
        """
        if self.enabled:
            self.enabled = False
            for name in self.name.split():
                self.display._enable_binding(name, self.fn, self.enabled)
                
class eventInfo(object):
    """
    Generic object used to supply event information to event handlers
    in the users code.
    
    These can hold just about anything:
    
        obj = eventInfo(x=3, y=4, time=34, .....)
        
    produces and object with x, y and time attributes set accordingly.
    
    """
    def __init__(self, **kw):
        self.__dict__.update(kw)
                
class display(cvisual.display_kernel, glcanvas.GLCanvas):
    # wrap_display_kernel.cpp makes available to Python, in addition to
    # render_scene, report_mouse_state, and report_mouse_state,
    # the methods report_window_resize, report_view_resize, and pick.
            
    def __init__(self, **keywords):
        cvisual.display_kernel.__init__(self)
        self._window_initialized = False
        self.window = None
        self.N = -1
        
        self.material = materials.diffuse
        # If visible is set before width (say), can get error "can't change window".
        # So deal with visible attribute separately.
        v = None
        if 'visible' in keywords:
            visible = keywords['visible']
            del keywords['visible']
        keys = list(keywords.keys())
        keys.sort()
        for kw in keys:
            setattr(self, kw, keywords[kw])
        if v is not None: setattr(self, 'visible', v)
        if 'ambient' not in keywords:
            self.ambient = (0.2,0.2,0.2)
            
        self._mt = _mouseTracker()
        self._captured = 0
        self._cursorx = self._cursory = 0

        self.select()
        
        if 'lights' not in keywords:
            distant_light( direction=(0.22, 0.44, 0.88), color=(0.8,0.8,0.8) )
            distant_light( direction=(-0.88, -0.22, -.44), color=(0.3,0.3,0.3) )
            
        self.bindings = {}

        if self.window is not None:
            self._activate(True)

    def select(self):
        cvisual.display_kernel.set_selected(self)
        
    def bind(self, namestring, fn):
        """
        attach events listed in namestring to function 'fn'
        """
        enabled = True # start out enabled
        for name in namestring.split():
            if name in EVENT_NAMES:
                elist = self.bindings.get(name,[])
                elist.append((enabled, fn))  # each entry is a list [enabled, fn]
                self.bindings[name] = elist
                
        return binding_enabler(self, namestring, fn, enabled)
        
    def unbind(self, namestring, fn=None):
        """
        take a particular function out of binding, or all bindings
        from events in namestring if fn is None.
        """
        for name in namestring.split():
            if name in EVENT_NAMES:
                if fn is None:
                    elist = []
                else:
                    elist = self.bindings.get(name,[])
                    if fn in elist:
                        elist.remove(fn)
                self.bindings[name] = elist
                
    def _enable_binding(self, name, in_fn, enable):
        new_list = []
        for enabled, fn in self.bindings.get(name,[]):
            if in_fn is fn:
                new_list.append((enable, fn))
            else:
                new_list.append((enabled, fn))
        self.bindings[name] = new_list
                
    def _dispatch_event(self, name, evt):
        for enabled, fn in self.bindings.get(name,[]):
            if enabled:
                fn(evt)

    def _make_canvas(self, parent):
        # http://xoomer.virgilio.it/infinity77/wxPython/glcanvas/wx.glcanvas.GLCanvas.html
        # http://xoomer.virgilio.it/infinity77/wxPython/glcanvas/wx.glcanvas.GLContext.html

        glcanvas.GLCanvas.__init__(self, parent, -1, pos=(self._x, self._y),
                                   size=(self._width-_dw, self._height-_dh))
        self._context = glcanvas.GLContext(self) # = wxGLCanvas&
        
        self.Bind(_wx.EVT_LEFT_DOWN, self._OnLeftMouseDown)
        self.Bind(_wx.EVT_LEFT_UP, self._OnLeftMouseUp)
        self.Bind(_wx.EVT_MIDDLE_DOWN, self._OnMiddleMouseDown)
        self.Bind(_wx.EVT_MIDDLE_UP, self._OnMiddleMouseUp)
        self.Bind(_wx.EVT_RIGHT_DOWN, self._OnRightMouseDown)
        self.Bind(_wx.EVT_RIGHT_UP, self._OnRightMouseUp)
        self.Bind(_wx.EVT_MOTION, self._OnMouseMotion)
        self.Bind(_wx.EVT_LEFT_DCLICK, self._OnLeftDClick)
        self.Bind(_wx.EVT_RIGHT_DCLICK, self._OnRightDClick)
        self.Bind(_wx.EVT_MIDDLE_DCLICK, self._OnMiddleDClick)
        
        #self.Bind(_wx.EVT_MOUSEWHEEL, self.OnMouseWheel)

        self.Bind(_wx.EVT_CHAR, self._OnCharEvent)
        self.Bind(_wx.EVT_KEY_DOWN, self._OnKeyDown)
        self.Bind(_wx.EVT_KEY_UP, self._OnKeyUp)
        
    def _report_resize(self):
        self.report_window_resize(int(self._x), int(self._y), int(self._width), int(self._height))
        self.report_view_resize(int(self._width-_dw), int(self._height-_dh))
        
    def _activate( self, a ):
        self._activated = a
        if a:
            _displays.add(self)            
            if not self._window_initialized:
                self._create()
                self._window_initialized = True         

    def _create(self):
        _displays.display_num += 1
        self.N = _displays.display_num
        self._x = self.x
        self._y = self.y
        self._width = self.width
        self._height = self.height
        if self.window is None:
            self.window = window(_make_panel=False, x=self._x, y=self._y,
                                 width=self._width, height=self._height, title=self.title)
            self.window._add_display(self)
            self._x = 0
            self._y = 0
            self._make_canvas(self.window.win)
        else:
            self._make_canvas(self.window.panel)
        self._x = self.x
        self._y = self.y
        self._report_resize()
        _Interact()

    def _destroy(self):
        _displays.remove(self)
        self.window.win.Destroy()
        self.window.win = None
        self.report_closed()
        
    def _paint(self):
        if not self._window_initialized: return
        self.SetCurrent(self._context)
        self.render_scene()
        self.SwapBuffers()

## mouse event codes: http://docs.wxwidgets.org/2.8.4/wx_wxmouseevent.html#wxmouseevent

    def _GetMouseInfo(self, evt):
        _x, _y = evt.GetPosition()
        return eventInfo(evt=evt, x=_x, y=_y, 
                    left=self._mt.leftIsDown, right=self._mt.rightIsDown,
                    middle=self._mt.middleIsDown)
    
    def _OnLeftDClick(self, evt):
        self._OnLeftMouseDown(evt)
        self._OnLeftMouseUp(evt)
        self._OnLeftMouseDown(evt)
        
    def _OnRightDClick(self, evt):
        self._OnRightMouseDown(evt)
        self._OnRightMouseUp(evt)
        self._OnRightMouseDown(evt)

    def _OnMiddleDClick(self, evt):
        self._OnMiddleMouseDown(evt)
        self._OnMiddleMouseUp(evt)
        self._OnMiddleMouseDown(evt)
        
    def _OnLeftMouseDown(self, evt):
        self._mt.leftDown()
        self._report_mouse_state(evt)
        self._dispatch_event('mousedown', self._GetMouseInfo(evt))
        evt.Skip() # to permit setting focus

    def _OnLeftMouseUp(self, evt):
        self._mt.leftUp()
        self._report_mouse_state(evt)
        _mouseInfo = self._GetMouseInfo(evt)
        self._dispatch_event('click', _mouseInfo)
        self._dispatch_event('mouseup', _mouseInfo)

    def _OnRightMouseDown(self, evt):
        self._mt.rightDown()
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnRightMouseUp(self, evt):
        self._mt.rightUp()
        self._report_mouse_state(evt)

    def _OnMiddleMouseDown(self, evt):
        self._mt.midDown()
        self._report_mouse_state(evt)
        evt.Skip() # to permit setting focus

    def _OnMiddleMouseUp(self, evt):
        self._mt.midUp()
        self._report_mouse_state(evt)

##    def OnMouseWheel(self, evt): # not supported by VPython 5.x
##        print(evt.GetWheelRotation(), evt.GetWheelDelta())

    def _OnMouseMotion(self, evt):
        self._report_mouse_state(evt)
        self._dispatch_event('mousemove', self._GetMouseInfo(evt))
        evt.Skip() # to permit setting focus
        
            
# Mouse state, including ctrl/alt etc. http://wxpython.org/docs/api/wx.MouseState-class.html
# On Mac:
# CTRL + 1-button mouse = no CTRL, right button, presumably because CTRL-mouse == "right button"
# ALT  + 1-button mouse = ALT, left button
# CMD  + 1-button mouse = CTRL and CMD, left button

    def _report_mouse_state(self, evt): # wx gives x,y relative to upper left corner
        x, y = evt.GetPosition()

        zooming = self._mt.isZooming(evt, self.userzoom, self.userspin)
        spinning = self._mt.isSpinning(evt, self.userzoom, self.userspin, zooming)

        lock = self._mt.checkLock(spinning, zooming)
        
        if lock and not self._captured:
            self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_BLANK))
            self._cursorx, self._cursory = evt.GetPosition()
            self.CaptureMouse()
            self._captured = True
        elif self._captured and not (spinning or zooming):
            self.window.win.WarpPointer(self._cursorx, self._cursory)
            self.window.win.SetCursor(_wx.StockCursor(_wx.CURSOR_ARROW))
            self.ReleaseMouse()          
            self._captured = False
        
        left = self._mt.leftIsDown
        right = spinning or self._mt.rightIsDown
        middle = zooming or self._mt.middleIsDown
        shift = evt.ShiftDown()
        ctrl = evt.ControlDown()
        alt = evt.AltDown()
        cmd = evt.CmdDown()
                
        #if _plat == 'Macintosh' and ctrl and cmd:
        #    ctrl = False
##        print('-------------------------')
##        print(x, y, left, middle, right, '   ', shift, ctrl, alt, cmd)
##        if trigger == 'leftdown' and not self._rightdown:
##            if ctrl:
##                right = 1
##                left = 0
##            elif alt:
##                middle = 1
##                left = 0

            
##        print(lock, x, y, left, middle, right, '   ', shift, ctrl, alt, cmd)
        self.report_mouse_state([left, right, middle],
                x, y,
                [shift, ctrl, alt, cmd],
                lock)
##        if (self._spinning or self._zooming): # reset mouse to original location
##                self.window.win.WarpPointer(self._cursorx, self._cursory)

    # caps lock not the same as shift key down
    def _OnCharEvent(self, evt):
        k = self._ProcessChar(evt)
        self.pushkey(k)
        self._dispatch_event('char', eventInfo(evt=evt, key=k))
        evt.Skip()
#
# The wx key codes:
#
# WXK_BACK     WXK_EXECUTE    WXK_F1   WXK_NUMPAD_SPACE      WXK_WINDOWS_LEFT
# WXK_TAB      WXK_SNAPSHOT   WXK_F2   WXK_NUMPAD_TAB        WXK_WINDOWS_RIGHT
# WXK_RETURN   WXK_INSERT     WXK_F3   WXK_NUMPAD_ENTER      WXK_WINDOWS_MENU
# WXK_ESCAPE   WXK_HELP       WXK_F4   WXK_NUMPAD_F1         WXK_SPECIAL1
# WXK_SPACE    WXK_NUMPAD0    WXK_F5   WXK_NUMPAD_F2         WXK_SPECIAL2
# WXK_DELETE   WXK_NUMPAD1    WXK_F6   WXK_NUMPAD_F3         WXK_SPECIAL3
# WXK_LBUTTON  WXK_NUMPAD2    WXK_F7   WXK_NUMPAD_F4         WXK_SPECIAL4
# WXK_RBUTTON  WXK_NUMPAD3    WXK_F8   WXK_NUMPAD_HOME       WXK_SPECIAL5
# WXK_CANCEL   WXK_NUMPAD4    WXK_F9   WXK_NUMPAD_LEFT       WXK_SPECIAL6
# WXK_MBUTTON  WXK_NUMPAD5    WXK_F10  WXK_NUMPAD_UP         WXK_SPECIAL7
# WXK_CLEAR    WXK_NUMPAD6    WXK_F11  WXK_NUMPAD_RIGHT      WXK_SPECIAL8
# WXK_SHIFT    WXK_NUMPAD7    WXK_F12  WXK_NUMPAD_DOWN       WXK_SPECIAL9
# WXK_ALT      WXK_NUMPAD8    WXK_F13  WXK_NUMPAD_PRIOR      WXK_SPECIAL10
# WXK_CONTROL  WXK_NUMPAD9    WXK_F14  WXK_NUMPAD_PAGEUP     WXK_SPECIAL11
# WXK_MENU     WXK_MULTIPLY   WXK_F15  WXK_NUMPAD_NEXT       WXK_SPECIAL12
# WXK_PAUSE    WXK_ADD        WXK_F16  WXK_NUMPAD_PAGEDOWN   WXK_SPECIAL13
# WXK_CAPITAL  WXK_SEPARATOR  WXK_F17  WXK_NUMPAD_END        WXK_SPECIAL14
# WXK_PRIOR    WXK_SUBTRACT   WXK_F18  WXK_NUMPAD_BEGIN      WXK_SPECIAL15
# WXK_NEXT     WXK_DECIMAL    WXK_F19  WXK_NUMPAD_INSERT     WXK_SPECIAL16
# WXK_END      WXK_DIVIDE     WXK_F20  WXK_NUMPAD_DELETE     WXK_SPECIAL17
# WXK_HOME     WXK_NUMLOCK    WXK_F21  WXK_NUMPAD_EQUAL      WXK_SPECIAL18
# WXK_LEFT     WXK_SCROLL     WXK_F22  WXK_NUMPAD_MULTIPLY   WXK_SPECIAL19
# WXK_UP       WXK_PAGEUP     WXK_F23  WXK_NUMPAD_ADD        WXK_SPECIAL20
# WXK_RIGHT    WXK_PAGEDOWN   WXK_F24  WXK_NUMPAD_SEPARATOR   
# WXK_DOWN                             WXK_NUMPAD_SUBTRACT    
# WXK_SELECT                           WXK_NUMPAD_DECIMAL     
# WXK_PRINT                            WXK_NUMPAD_DIVIDE
# 
# With time we can include all of these..
#

    def _ProcessKey(self, evt):
        #
        # Process event to keystroke for Key Up/Down events.
        #
        key = evt.GetKeyCode()
        shift = evt.ShiftDown()
        if key > 127:
            if   key == 310: k = 'break'
            elif key == _wx.WXK_END: k = 'end'
            elif key == _wx.WXK_HOME: k = 'home'
            elif key == _wx.WXK_LEFT: k = 'left'
            elif key == _wx.WXK_UP: k = 'up'
            elif key == _wx.WXK_RIGHT: k = 'right'
            elif key == _wx.WXK_DOWN: k = 'down'
            elif key == _wx.WXK_INSERT: k = 'insert'
            elif key == _wx.WXK_F1: k = 'f1'
            elif key == _wx.WXK_F2: k = 'f2'
            elif key == _wx.WXK_F3: k = 'f3'
            elif key == _wx.WXK_F4: k = 'f4'
            elif key == _wx.WXK_F5: k = 'f5'
            elif key == _wx.WXK_F6: k = 'f6'
            elif key == _wx.WXK_F7: k = 'f7'
            elif key == _wx.WXK_F8: k = 'f8'
            elif key == _wx.WXK_F9: k = 'f9'
            elif key == _wx.WXK_F10: k = 'f10'
            elif key == _wx.WXK_PAGEUP: k = 'page up'
            elif key == _wx.WXK_PAGEDOWN: k = 'page down'
            elif key == _wx.WXK_SHIFT: k = 'shift'            
            else: k = 'invalid key'
        else:
            k = chr(key)
            if not shift: k = _lower(k)
        return k

    def _ProcessChar(self, evt):
        #
        # Process event to keystroke for Char events.
        #
        key = evt.GetKeyCode()
        shift = evt.ShiftDown()
        if key > 127:
            if   key == 310: k = 'break'
            elif key == 312: k = 'end'
            elif key == 313: k = 'home'
            elif key == 314: k = 'left'
            elif key == 315: k = 'up'
            elif key == 316: k = 'right'
            elif key == 317: k = 'down'
            elif key == 322: k = 'insert'
            elif key == 340: k = 'f1'
            elif key == 341: k = 'f2'
            elif key == 342: k = 'f3'
            elif key == 343: k = 'f4'
            elif key == 344: k = 'f5'
            elif key == 345: k = 'f6'
            elif key == 346: k = 'f7'
            elif key == 347: k = 'f8'
            elif key == 348: k = 'f9'
            elif key == 349: k = 'f10'
            elif key == 366: k = 'page up'
            elif key == 367: k = 'page down'
            else: k = 'invalid key'
        else:
            if shift: k = _shifted[key]
            else: k = _unshifted[key]
        return k
    
    def _OnKeyDown(self, evt):
        k = self._ProcessKey(evt)    
        self._dispatch_event('keydown', eventInfo(evt=evt, key=k))
        evt.Skip()
        
    def _OnKeyUp(self, evt):
        k = self._ProcessKey(evt)    
        self._dispatch_event('keyup', eventInfo(evt=evt, key=k))
        evt.Skip()

    def _return_objects(self):
        return tuple([ o for o in self._get_objects() if not isinstance(o, cvisual.light) ])
    objects = property( _return_objects, None, None)

    def _get_lights(self):
        # TODO: List comprehension used for Python 2.3 compatibility; replace with
        #   generator comprehension
        return tuple([ o for o in self._get_objects() if isinstance(o, cvisual.light) ])
    
    def _set_lights(self, n_lights):
        old_lights = self._get_lights()
        for lt in old_lights:
            lt.visible = False

        if (type(n_lights) is not list) and (type(n_lights) is not tuple):
            n_lights = [n_lights] # handles case of scene.lights = single light
        for lt in n_lights:
            if isinstance( lt, cvisual.light ):  #< TODO: should this be allowed?
                lt.display = self
                lt.visible = True
            else:
                lum = cvisual.vector(lt).mag
                distant_light( direction=cvisual.vector(lt).norm(),
                               color=(lum,lum,lum),
                               display=self )
        
    ambient = property( cvisual.display_kernel._get_ambient, cvisual.display_kernel._set_ambient)
    range = property( cvisual.display_kernel._get_range, cvisual.display_kernel._set_range)
    lights = property( _get_lights, _set_lights, None)

class _ManageDisplays(): # a singleton
    def __init__(self):
        set_wait(wait)
        self.displays = []
        self.window_num = 0     
        self.display_num = 0

    def add(self, d):
        self.displays.append(d)

    def remove(self, d):
        self.displays.remove(d)

    def paint_displays(self):
        for d in self.displays:
            d._paint()

_displays = _ManageDisplays()
displays = _displays.displays
_evtloop = _wx.GUIEventLoop()
_wx.EventLoop.SetActive(_evtloop)
_isMac = ('wxOSX' in _wx.PlatformInfo)

# The essence of _Interact was provided by Robin Dunn, developer of wxPython
def _Interact():

    for d in displays:
        d._dispatch_event("redraw", None)

    _displays.paint_displays()
    
    for d in displays:
        d._dispatch_event("draw_complete", None)
    
    while not _evtloop.Pending() and _evtloop.ProcessIdle(): pass
    if _wx.GetApp(): _wx.GetApp().ProcessPendingEvents()
    if _isMac and not _evtloop.Dispatch(): return
    # Currently on wxOSX Pending always returns true, so the
    # ProcessIdle above is not ever called. Call it here instead.
    if _isMac: _evtloop.ProcessIdle()
    
    while True:
        checkAgain = False
        if _wx.GetApp() and _wx.GetApp().HasPendingEvents():
            _wx.GetApp().ProcessPendingEvents()
            checkAgain = True
        if not _isMac and _evtloop.Pending():
            _evtloop.Dispatch()
            checkAgain = True
        if not checkAgain:
            break
        
from rate_function import RateKeeper as _rk
rate = _rk(interactFunc=_Interact)

if _plat == 'Windows':
    # On Windows, the best timer is supposedly time.clock()
    _clock = _time.clock
else:
    # On most other platforms, the best timer is supposedly time.time()
    _clock = _time.time

def sleep(dt):
    tend = _clock() + dt
    _Interact() # make sure we call _Interact at least once
    while _clock() < tend:
        rate(30)
    
##print('--------------')
### Note that Mac info is incorrect
##print(_wx.SystemSettings.GetMetric(_wx.SYS_SCREEN_X))    # 1920, 1440
##print(_wx.SystemSettings.GetMetric(_wx.SYS_SCREEN_Y))    # 1200, 900
##print(_wx.SystemSettings.GetMetric(_wx.SYS_BORDER_X))    # 1, -1 (Windows, Mac)
##print(_wx.SystemSettings.GetMetric(_wx.SYS_BORDER_Y))    # 1, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X)) # 8, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y)) # 8, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y))      #  20, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y))   #  22, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_EDGE_X))      #   2, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_EDGE_Y))      #   2, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_WINDOWMIN_X)) # 132, -1
##print(_wx.SystemSettings.GetMetric(_wx.SYS_WINDOWMIN_Y)) #  38, -1
##print('--------------')

# Title bar height is FRAMESIZE_Y + CAPTION_Y = 30 on Windows
# Menu bar height is MENU_Y = 20 on Windows
# Thickness of bottom is FRAMESIZE_Y = 8 on Windows
#   So height of canvas is scene.height - 58
#   and width of canvas is scene.width - 16

# The canvas size is (self._width-_dw, self._height-_dh)
if _plat == 'Macintosh':
    _dw = 0
    _dh = 22
elif _plat == 'Unix': # e.g., Linux
    _dw = 0
    _dh = 0
else:
    _dw = 2*(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_X))
    _dh = 2*(_wx.SystemSettings.GetMetric(_wx.SYS_FRAMESIZE_Y)) + \
            _wx.SystemSettings.GetMetric(_wx.SYS_CAPTION_Y) + \
            _wx.SystemSettings.GetMetric(_wx.SYS_MENU_Y)
        
##        # The canvas size can also be determined by comparing GetSize() and GetClientSize(),
##        # after the window and canvas have been created:
##        size = self.window.win.GetSize()
##        canvas_size = self.window.win.GetClientSize()
##        self._dw = size[0] - canvas_size[0] # canvas is dw thinner than scene.width
##        self._dh = size[1] - canvas_size[1] # canvas is dh shorter than scene.height

# Tables for converting US keyboard inputs to characters
_unshifted = ['', '', '', '', '', '', '', '', 'backspace', 'tab', # 0-9
   '', '', '', 'enter', '', '', 'shift', 'ctrl', 'alt', '', # 10-19
   'caps lock', '', '', '', '', '', '', 'esc', '', '', #20-29
   '', '', ' ', '', '', '', '', '', '', "'", # 30-39
   '', '', '', '', ',', '-', '.', '/', '0', '1', # 40-49
   '2', '3', '4', '5', '6', '7', '8', '9', '', ';', # 50-59
   '', '=', '', '', '', '', '', '', '', '', # 60-69
   '', '', '', '', '', '', '', '', '', '', # 70-79
   '', '', '', '', '', '', '', '', '', '', # 80-89
   '', '[', '\\', ']', '', '', '`', 'a', 'b', 'c', # 90-99
   'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', # 100-109
   'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', # 110-119
   'x', 'y', 'z', '', '', '', '', 'delete'] #120-127
   
_shifted = ['', '', '', '', '', '', '', '', 'backspace', 'tab', # 0-9
   '', '', '', 'enter', '', '', 'shift', 'ctrl', 'alt', 'break', # 10-19
   'caps lock', '', '', '', '', '', '', 'esc', '', '', #20-29
   '', '', '', '!', '"', '#', '$', '%', '&', '', # 30-39
   '(', ')', '*', '+', '', 'insert', 'delete', '', '', '!', # 40-49
   '@', '#', '$', '%', '^', '&', '*', '(', ':', '', # 50-59
   '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', # 60-69
   'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', # 70-79
   'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', # 80-89
   'Z', '', '', '', '^', '_', '0', '1', '2', '3', # 90-99
   '4', '5', '6', '7', '8', '9', '*', '+', '', '', # 100-109
   '', '', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', # 110-119
   'f9', 'f10', '', '{', '|', '}', '~', 'delete'] #120-127

