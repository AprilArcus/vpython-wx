<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!-- InstanceBegin template="/Templates/template.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- InstanceBeginEditable name="doctitle" -->
<title>mouse</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<link href="VisualRef.css" rel="stylesheet" type="text/css" />
<!-- InstanceEndEditable -->
<script type="text/javascript">
<!--
function MM_jumpMenu(targ,selObj,restore){ //v3.0
  eval(targ+".location='"+selObj.options[selObj.selectedIndex].value+"'");
  if (restore) selObj.selectedIndex=0;
}
//-->
</script>
<link href="VisualRef.css" rel="stylesheet" type="text/css" />
</head>

<body>
<table width="800" border="0" cellpadding="1" cellspacing="0">
  <!--DWLayoutDefaultTable-->
  <tr>
    <td width="10" valign="top" bgcolor="#FFFFFF"><!--DWLayoutEmptyCell-->&nbsp;</td>
    <td width="10" height="272" valign="top" bgcolor="#DDDDDD"><p>&nbsp;</p>    </td>
    <td width="173" valign="top" bgcolor="#DDDDDD"><p class="Normal"><a href="index.html">Home</a></p>
      <p class="Normal">If you're new to Python <br />
      and VPython: <a href="VisualIntro.html">Introduction</a></p>
      <p class="Normal">A VPython <a href="VPython_Intro.pdf" target="_blank">tutorial</a></p>
      <p class="Normal"><a href="primitives.html">Pictures</a> of 3D objects</p>
<p><select id="menu1" onchange="jumpMenu(this)"></select></p>
<p><select id="menu2" onchange="jumpMenu(this)"></select></p>
<p><select id="menu3" onchange="jumpMenu(this)"></select></p>
        
    <p class="Normal">What's new in <a new_features.html">VPython 6</a></p>
    <p class="Normal"><a href="http://vpython.org" target="_blank">VPython web site</a><br />
      <a href="license.txt" target="_blank">VPython license</a><br />
      <a href="http://www.python.org" target="_blank">Python web site</a> <br />
      <a href="http://www.python.org/doc/2.5.2/lib/module-math.html" target="_blank">Math module</a> (sqrt etc.)<br />
    <a href="http://www.scipy.org/Documentation" target="_blank">Numpy module</a> (arrays)    </p></td>
    <td width="21" valign="top" bgcolor="#FFFFFF"><!--DWLayoutEmptyCell-->&nbsp;</td>
    <td width="586" rowspan="2" valign="top"><!-- InstanceBeginEditable name="content" -->

        <h1 class="Heading-1"> <font color="#0000A0">Mouse Interactions</font></h1>

        <p class="Normal"><strong><font color="#0000A0">Introduction</font></strong></p>
        <p class="Normal"> Mouse objects are obtained from the mouse attribute of a 
          display object such as <span class="attribute">scene</span>. For example, 
          the current state of the the mouse in the default window created by VPython is <span class="attribute">scene.mouse</span>. For basic examples of mouse handling, 
          see <a href="mouse_click.html">Click example</a>, <a href="mouse_drag.html">Drag 
            example</a>, and <a href="#pause">Pausing for either mouse or keyboard input</a>.</p>
        <p class="Normal"> A mouse object has a group of attributes corresponding to 
          the current state of the mouse. It also has functions <span class="attribute">getevent()</span> and <span class="attribute">getclick()</span>, which return an object with 
          similar attributes corresponding to the state of the mouse when the user last 
          did something with the mouse buttons. If the user has not already done something 
          with the mouse buttons, <span class="attribute">getevent()</span> and <span class="attribute">getclick()</span> will stop program execution until this happens.</p>
        <p class="Normal"><strong><font color="#0000A0">Different kinds of mouse</font></strong></p>
        <p class="Normal">The mouse routines can handle a three-button mouse,
          with &quot;left&quot;, 
          &quot;right&quot;, and &quot;middle&quot; buttons. For systems with
          a two-button  mouse, the &quot;middle&quot; button consists of the
          left and right buttons  pressed together. For systems with a one button
          mouse, the right button is  invoked by holding down the Command key,
          and the middle button is invoked by holding down the Option key. </p>
        <p class="Normal"><strong><font color="#0000A0">Design for left-button events if possible</font></strong></p>
        <p class="Normal">VPython 5 provides the basic mouse event functionality that was present in VPython 3 for handling events from right and middle buttons when userspin or userzoom is disabled, out of concern for supporting old programs. However, it has become evident that there are limitations to this approach which could preclude some kinds of mouse handling that people might want to do in the future. For example, you might want to allow userspin with right drags yet also pick up right clicks. For that reason it is conceivable that future developments in this area might break existing programs, and therefore for maximum forward compatibility it is prudent to use only left-button interactions in new programs.</p>
      <p class="Normal"><strong> <font color="#0000A0">Current state of mouse</font></strong></p>
        <p class="attributes"> <span class="attribute">pos</span> The current 3D position 
          of the mouse cursor; <span class="attribute">scene.mouse.pos</span>. VPython 
          always chooses a point in the plane parallel to the screen and passing through <span class="attribute">display.center</span>. (See <a href="#alternative">Projecting 
            mouse information onto a given plane</a> for other options.)</p>
<p class="attributes"> <span class="attribute">pick</span> The nearest object 
        in the scene which falls under the cursor, or None. At present curve, label, helix, extrusion, and faces cannot be picked. The picked object is <span class="attribute">scene.mouse.pick</span>.</p>
        <p class="attributes"> <span class="attribute">pickpos</span> The 3D point on 
          the surface of the picked object which falls under the cursor, or None; <span class="attribute">scene.mouse.pickpos</span>.</p>
        <p class="attributes"> <span class="attribute">camera</span> The read-only current 
          position of the camera as positioned by the user, <span class="attribute">scene.mouse.camera</span><font color="#000000">. 
            For example, <span class="attribute">mag(scene.mouse.camera-scene.center)</span> is the distance from the center of the scene to the current position of the 
            camera. If you want to set the camera position and direction by program, use <span class="attribute">scene.forward</span> and <span class="attribute">scene.center</span>, 
            described in <a class="sectref" href="display.html">Controlling Windows</a>.</font> </p>
        <p class="attributes"> <span class="attribute">ray</span> A unit vector pointing 
          from camera in the direction of the mouse cursor. The points under the mouse 
          cursor are exactly {<span class="attribute"> camera + t*ray</span> for <span class="attribute">t&gt;0</span>}.</p>
        <p class="attributes"> &nbsp;&nbsp;&nbsp;The <span class="attribute">camera</span> and <span class="attribute">ray</span> attributes together define all of the 
          3D points under the mouse cursor.</p>
        <p class="attributes"><span class="attribute">project()</span> Projects position 
          onto a plane. See <a href="#alternative">Projecting mouse position onto a given 
            plane</a>. </p>
        <p class="attributes"><span class="attribute">alt</span> = True if the ALT key 
          is down, otherwise False</p>
        <p class="attributes"><span class="attribute">ctrl</span> = True if the CTRL key 
          is down, otherwise False (for a one-button mouse, meaningful only if mouse buttons 
          up)</p>
        <p class="attributes"><span class="attribute">shift</span> = True if the SHIFT 
          key is down, otherwise False (for a one-button mouse, meaningful only if mouse 
          buttons up)        </p>
        <p class="Normal">Additional information is provided when an event occurs (mouse pressed or released, or mouse moved):</p>
        <p class="attributes"><span class="attribute">press</span> = 'left' 
          for a press event, or 'right' 
          or 'middle', or None. A<span class="Normal"> press event occurs when a mouse button 
            is depressed.</span></p>
        <p class="attributes"><span class="attribute">click</span> = 'left' for
          a click event, or 'right' or 'middle', or None. <span class="Normal">A click event occurs when all mouse buttons 
            are released with no movement of the mouse. (This is also a release event.) Note that a click event happens when the mouse button is <i>released</i>.</span> See <a href="mouse_click.html">Click example</a>.</p>
        <p class="attributes"><span class="attribute">drag</span> = 'left' for
          a drag event, or 'right' or 'middle', or None;
          in this case <span class="attribute">pos</span> <span class="attribute"></span>and other attributes correspond to the state 
          of the mouse at the time of the original press event, so as not to lose initial 
          position information. <span class="Normal">A drag event occurs when the mouse is moved 
            slightly after a press event, with mouse buttons still down. This can be used to signal the beginning of dragging an 
            object. </span>See <a href="mouse_drag.html">Drag example</a>.</p>
        <p class="attributes"><span class="attribute">drop</span> = 'left' for
          a drop event, or 'right' or 'middle', or None. <span class="Normal">A drop event occurs when the mouse buttons
            are released after a drag event.  (This is also a release event.)</span></p>
        <p class="attributes"><span class="attribute">release</span> = 'left'
          following click and drop events, indicating which button was released,
          or 'right' or 'middle', or None. <span class="Normal">A release event occurs when the mouse buttons
            are released after a click or drag event.</span></p>
        <p class="attributes"><span class="attribute">button</span> = 'left', 'right', or 'middle'. After executing <span class="attribute">mm = scene.mouse.getevent(), </span>the expression <span class="attribute">mm.button == 'left'</span> is true if the left button is currently down. </p>
<p class="Normal"><strong><font color="#0000A0">Polling and callback</font></strong></p>
        <p class="Normal">There are two different ways to get a mouse event, &quot;polling&quot; and &quot;callback&quot;. In polling, you continually check <strong>scene.mouse.events</strong> to see whether any events are waiting to be processed, and you use <strong>scene.mouse.getevent()</strong> to get the next event to process. Prior to VPython 6, this was the only way you could handle mouse or keyboard events.</p>
        <p class="Normal">If you use the callback method, you specify a function to be executed when a specific type of event occurs, and the function is sent the event information when the specified type of event occurs. For many purposes this is a better way to handle mouse and keyboard events, and we will discuss it first. Programs that use polling will continue to work, but you cannot mix polling and callback approaches: you must use one or the other.</p>
        <p class="Normal"><strong><font color="#0000A0">Handling  events with callbacks</font></strong></p>
        <p class="Normal">Here is a simple example of how to use callbacks to process events:</p>
        <p class="program">from visual import *<br />
          s = sphere(color=color.cyan)<br />
          <br />
          def 
        change():<br />
&nbsp;&nbsp;&nbsp;&nbsp;if s.color == color.cyan:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.color = color.red<br />
&nbsp;&nbsp;&nbsp;&nbsp;else:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s.color = color.cyan<br />
<br />
scene.bind('click', change)</p>
        <p class="Normal">We define a &quot;function&quot; named &quot;change&quot;. Then we &quot;bind&quot; this function to click events occurring in the display named &quot;scene&quot;. When VPython detects that a click event has occurred, VPython calls the bound function, which in this case toggles the sphere's color between cyan and red.</p>
        <p class="Normal">This operation is called a &quot;callback&quot; because with scene.bind you register with VPython that you want to be called back any time there is a click event. Here are the built-in events that you can specify in a bind operation:</p>
        <p class="program">Mouse: &nbsp;&nbsp;&nbsp;click, mousedown, mousemove, mouseup<br />
          Keyboard: keydown, keyup, 
        char<br />
        Other: &nbsp;&nbsp;&nbsp;redraw, draw_complete </p>
        <p class="Normal">The event 'mousedown' or 'mouseup' occurs when you press or release the left button on the mouse, and the 'mousemove' event occurs whenever the mouse moves, whether or not a button is depressed. The events 'keydown', 'keyup', and 'char' are discussed in the <a href="keyboard.html"><strong>keyboard</strong></a> section. A 'redraw' event occurs just before the 3D scene is redrawn on the screen, and a 'draw_complete' event occurs just after the redrawing (these event have rather technical uses such as timing how often redrawings occur, or how much time they take).</p>
        <p class="Normal">You can bind more than one event to a function. The following will cause the callback function to be executed whether you click with the mouse or press a key on the keyboard:</p>
        <p class="program">scene.bind('click keydown', change)        </p>
        <p class="Normal">The example program <span class="attribute">eventHandlers.py</span> illustrates the callback method for handling many kinds of events.</p>
        <p class="Normal"><strong><font color="#0000A0">Details of the event</font></strong></p>
        <p class="Normal">You can get detailed information about the event by writing the callback function like this:</p>
        <p class="program">def info(evt):<br />
&nbsp;&nbsp;&nbsp;&nbsp;print(evt.event, evt.pos, evt.button) </p>
      <p class="Normal">After specifying an argument in the definition of the callback function ('evt' in this case), when the function is called due to a specified event happening VPython sends the function the information contained in scene.mouse, plus additional event information (press, release, button, etc.), plus 'event', which is the name of the event that triggered the callback, such as 'mousedown' or 'click'. The name of the argument need not be 'evt'; use whatever name you like.</p>
      <p class="Normal">You can also arrange to have VPython send the callback function some message or quantity of your own. Here is a revised version of the color-change example, in which in the bind operation we specify an additional argument to be sent, the name of the object whose color should change:</p>
      <p class="program">from visual import *<br />
        s = sphere(color=color.cyan)<br />
  <br />
        def 
        change(evt, obj):<br />
  &nbsp;&nbsp;&nbsp;&nbsp;if obj.color == color.cyan:<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.color = color.red<br />
  &nbsp;&nbsp;&nbsp;&nbsp;else:<br />
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj.color = color.cyan<br />
  <br />
        scene.bind('click', change, s)      </p>
      <p class="Normal">Normally, only the left mouse button will trigger an event, but if you specify scene.userspin = False, so the right button is no longer bound to camera rotation, clicking with the right mouse button will cause a callback. Similarly, if you specify scene.userzoom = False, you can click with the middle button (or left+right buttons).</p>
      <p class="Normal"><strong><font color="#0000A0">Custom events: triggers</font></strong></p>
<p class="Normal">def clickFunc():<br />
      print &quot;I've been clicked!&quot;, scene.mouse.pos<br />
      s = sphere(pos=scene.mouse.pos)<br />
      scene.trigger(&quot;ball&quot;, s, 2, 5)<br />
  <br />
  def ballFunc(newball, a, b, c=3):<br />
      print &quot;ball event occured!&quot;, newball, a, b, c<br />
      newball.color=color.blue<br />
  <br />
  scene.bind(&quot;click&quot;, clickFunc)<br />
  scene.bind(&quot;ball&quot;, ballFunc)<br />
  <br />
  b = box(pos=(1,0,0))</p>
<p class="Normal">&nbsp;</p>
<p class="Normal"><strong><font color="#0000A0">Handling events with polling</font></strong>        </p>
<p class="Normal">The following information on how to handle events using polling is still valid, but you are encouraged to consider using the more powerful callback approach when writing new programs. Remember that you cannot mix the two schemes. You can use either callback or polling in a program, but not both.</p>
<p class="Normal">The simplest polling mouse interaction is to wait for a mouse click:</p>
        <p class="attributes"> <span class="attribute">scene.mouse.getclick()</span> Wait for a mouse click. If you say <strong>m = scene.mouse.getclick()</strong>, the variable m gives information about the event. For example, <strong>m.pos</strong> is the location of the mouse at the time of the click event.</p>
      <p class="Normal">It is a useful debugging technique to insert <span class="attribute">scene.mouse.getclick()</span> into your program at a point where you would like to stop temporarily to examine 
          the scene. Then just click to proceed.</p>
      <p class="Normal">In the <a href="mouse_drag.html">Drag 
          example</a> you will see how to use event-handling functions to process mouse events continuously.        </p>
        <p class="attributes"><span class="attribute">events</span> The number of events 
          (press, click, drag, or drop) which have been queued; e.g. <span class="attribute"> scene.mouse.events</span>.<br />
        <span class="attribute">scene.mouse.events = 0 </span>may be used to discard 
          all input. No value other than zero can be assigned.</p>
        <p class="attributes"> <span class="attribute">getevent()</span> Obtains the 
          earliest mouse event and removes it from the input queue. If no events are 
          waiting in the queue (that is, if <span class="attribute">scene.mouse.events</span> is zero), <span class="attribute">getevent()</span> waits until the user enters 
          a mouse event (press, click, drag, or drop). <span class="attribute">getevent()</span> returns an object with attributes similar to a mouse object: <span class="attribute">pos</span>, <span class="attribute">button, pick</span>, <span class="attribute">pickpos</span>, <span class="attribute">camera</span>, <span class="attribute">ray</span>, <span class="attribute">project()</span>, <span class="attribute">alt</span>, <span class="attribute">ctrl,</span> and <span class="attribute">shift</span>. 
          These attributes correspond to the state of the mouse when the event took 
          place. For example, after executing <span class="attribute">mm = scene.mouse.getevent()</span> you can look at the various properties of this event, such as <span class="attribute">mm.pos</span>, <span class="attribute">mm.pick</span>, <span class="attribute">mm.drag</span> (see below), etc. </p>
        <p class="Normal">If you are interested in every type of event (press, click, 
          drag, and drop), you must use <span class="attribute">events</span> and <span class="attribute">getevent()</span>. 
          If you are only interested in left click events (left button down and up without 
          significant mouse movement), you can use <span class="attribute">clicked</span> and <span class="attribute">getclick()</span>:</p>
        <p class="attributes"><span class="attribute">clicked</span> The number of left 
          clicks which have been queued; e.g. <span class="attribute"> scene.mouse.clicked</span>.<br />
          This does not include a count of nonclick events (press, drag, or drop).</p>
      <p class="attributes"><span class="attribute">getclick()</span> Obtains the 
          earliest mouse left click event (pressing the left button and releasing it 
          in nearly the same position) and removes it from the input queue, discarding 
          any earlier press, drag, or drop events. If no clicks are waiting in the queue 
          (that is, if <span class="attribute">scene.mouse.clicked</span> is zero), <span class="attribute">getclick()</span> waits until the user clicks. Otherwise <span class="attribute">getclick()</span> is just like <span class="attribute">getevent()</span>. </p>
        <p class="Normal">It is a useful debugging technique to insert <span class="attribute">scene.mouse.getclick()</span> into your program at a point where you would like to stop temporarily to examine 
          the scene. Then just click to proceed.</p>
      <p class="Normal">Between a drag event (start of dragging) and a drop event 
        (end of dragging), there are no mouse events but you can examine the continuously 
        updated position of the mouse indicated by <span class="attribute">scene.mouse.pos</span>. </p>
      <p class="Normal">Normally, dragging with right or middle button represents 
        spin or zoom, and is handled automatically by VPython, so you can check for 
        left-button drag or drop events simply by checking whether <span class="attribute">drag</span> or <span class="attribute">drop</span> is true (in Python, a nonempty string 
        such as 'left' is true, None is false). Unless you disable user zoom (<span class="attribute">scene.userzoom 
          = False</span>), <span class="attribute">press, click</span>, <span class="attribute">drag, drop</span>, 
        and <span class="attribute">release</span> with the middle button are invisible 
        to your program. Unless you disable user spin (<span class="attribute">scene.userspin 
          = False</span>), <span class="attribute">press, click</span>, <span class="attribute">drag, drop</span>, 
        and <span class="attribute">release</span> with the right button are invisible 
        to your program.</p>
      <p class="Normal"><font color="#0000A0"><a name="alternative" id="alternative"></a><strong>Projecting 
          mouse position onto a given plane</strong></font></p>
        <p class="Normal"> Here is a way to get the mouse position relative to a particular 
          plane in space:</p>
        <p class="program"> temp = scene.mouse.project(normal=(0,1,0), point=(0,3,0))<br />
        if temp: # temp is None if no intersection with plane<br />
        &nbsp;&nbsp;&nbsp;&nbsp;ball.pos = temp</p>
        <p class="Normal"> This projects the mouse cursor onto a plane that is perpendicular 
          to the specified normal. If <span class="attribute">point</span> is not 
          specified, the plane passes through the origin. It returns a 3D position, 
          or None if the projection of the mouse misses the plane.</p>
        <p class="Normal"> In the example shown above, the user of your program will 
          be able to use the mouse to place balls in a plane parallel to the xy plane, 
          a height of 3 above the xy plane, no matter how the user has rotated the point 
          of view.</p>
        <p class="Normal">You can instead specify a perpendicular distance <span class="attribute">d</span> from the origin to the plane that is perpendicular to the specified normal. 
          The example above is equivalent to</p>
        <p class="program"> temp = scene.mouse.project(normal=(0,1,0), d=3)</p>
        <p class="Normal"><font color="#0000A0"><strong><a name="pause" id="pause"></a>Pausing for mouse or keyboard input</strong></font></p>
        <p class="Normal"> Often you want to pause for either mouse or keyboard input. Copy the following function into your program, and then insert <strong>pause()</strong> wherever you want to pause.</p>
        <p class="program">def pause():<br />
&nbsp;&nbsp;&nbsp;&nbsp;while True:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rate(30)<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if scene.mouse.events:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m = scene.mouse.getevent()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if m.click == 'left': return<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif scene.kb.keys:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = scene.kb.getkey()<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return      </p>
        <p class="Normal">As of VPython 6, an alternative to this function is simply to write <strong>scene.waitfor('click keydown')</strong>.</p>
    <!-- InstanceEndEditable --></td>
  </tr>
  <tr>
    <td height="16" colspan="4"></td>
  </tr>
</table>
</body>
<script type="text/javascript" language="javascript" src="navigation.js"></script>
<!-- InstanceEnd --></html>
